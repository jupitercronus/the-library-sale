<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profile Header - the library sale</title>
    <!-- Google Fonts Import -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=B612+Mono&family=Dokdo&family=Kirang+Haerang&family=M+PLUS+2&family=Syne+Mono&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-auth-compat.js"></script>
    <!-- App Utilities -->
    <script src="utils.js"></script>
    <script src="modal-manager.js"></script>
    <script src="scanner-utils.js"></script>
    <script src="cache.js"></script>
    <script src="search-ui.js"></script> 

    <!-- Styles -->
    <link rel="stylesheet" href="styles/variables.css">
    <link rel="stylesheet" href="styles/base.css">  
    <link rel="stylesheet" href="styles/components.css">
    <link rel="stylesheet" href="styles/pages.css">
    
    <!-- Main Script -->
    <script src="main.js" defer></script>
</head>
<body>
    <header id="navbar-placeholder"></header>

    <main class="main-container">
        <!-- Profile Header Card -->
        <section class="profile-header-card">
            <!-- Profile Header with avatar and badges -->
            <div class="profile-header-content">
                <div class="profile-avatar-section">
                    <div class="profile-avatar" id="profileAvatar" title="Click to change avatar (coming soon)">
                        <span class="icon icon-person"></span>
                    </div>
                    <h1 class="username-display" id="usernameDisplay">Loading...</h1>
            
                    <div class="profile-actions">
                        <div class="profile-action-item">
                            <a href="my-stacks.html" class="btn btn-lg btn-secondary" title="my stacks">
                                <span class="icon icon-poster"></span>
                            </a>
                            <span class="action-subtitle">my stacks</span>
                        </div>
                    
                        <div class="profile-action-item">
                            <a href="lists.html" class="btn btn-lg btn-secondary" title="my lists">
                                <span class="icon icon-list"></span>
                            </a>
                            <span class="action-subtitle">my lists</span>
                        </div>
                    </div>
                    
                    <div class="profile-badges">
                        <div class="badges-grid" id="badgesGrid">
                            </div>
                    </div>
                </div>
                <!-- Main Profile Info -->
                <div class="profile-main-info">
                    <!-- Movie Quote Section -->
                    <div class="movie-quote-section">
                        <div class="quote-label">my fav quote</div>
                        <div class="movie-quote-display empty" id="movieQuoteDisplay">
                            Click to add your favorite movie quote...
                        </div>
                        <textarea class="movie-quote-input" id="movieQuoteInput" style="display: none;" placeholder="Enter your favorite movie quote..." maxlength="200"></textarea>
                        <div class="quote-edit-actions" id="quoteEditActions">
                            <button class="btn btn-sm btn-success" id="saveQuoteBtn" title="Save Quote">
                                <span class="icon icon-confirm icon-sm"></span>
                            </button>
                            <button class="btn btn-sm btn-secondary" id="cancelQuoteBtn" title="Cancel">
                                <span class="icon icon-close icon-sm"></span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Last Watched Section -->
                    <div>
                        <div class="quote-label" style="margin-bottom: var(--space-md);">Last Watched</div>
                        <div class="last-watched-section" id="lastWatchedSection">
                            <div class="last-watched-empty">No movies watched yet</div>
                        </div>
                    </div>
                    <!-- Quick Stats -->
                    <div>
                        <div class="quote-label" style="margin-bottom: var(--space-md);">Collection Stats</div>
                        <div class="quick-stats-section-expanded">
                            <!-- First row - existing stats -->
                            <div class="stat-item">
                                <span class="stat-number" id="totalMoviesCount">-</span>
                                <span class="stat-label">Movies</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number" id="totalTVCount">-</span>
                                <span class="stat-label">TV Shows</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number" id="hoursWatchedCount">-</span>
                                <span class="stat-label">Hours (2025)</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number" id="avgRatingDisplay">-</span>
                                <span class="stat-label">Avg Rating</span>
                            </div>
                            
                            <!-- Second row - new favorites stats -->
                            <div class="stat-item stat-wide">
                                <span class="stat-label">Top Directors</span>
                                <span class="stat-text" id="favoriteDirectorsDisplay">-</span>
                            </div>
                            <div class="stat-item stat-wide">
                                <span class="stat-label">Top Cast</span>
                                <span class="stat-text" id="favoriteCastDisplay">-</span>
                            </div>
                        </div>
                    </div>
                </div> <!-- Close profile-main-info -->
            </div> <!-- Close profile-header-content -->
        </section> <!-- Close profile-header-card -->

        <!-- Movie DNA Section -->
     <!-- Fun Facts Section -->
        <section class="profile-header-card">
            <div class="quote-label" style="margin-bottom: var(--space-md);">fun facts</div>            
            <div class="movie-dna-grid">
                <!-- Genre Breakdown -->
                <div class="dna-section">
                    <h3 class="dna-section-title">Genre Breakdown</h3>
                    <div class="genre-pie-chart" id="genrePieChart">
                        <div class="pie-chart-legend" id="genreLegend"></div>
                    </div>
                </div>
                
                <!-- Yearly Progress -->
                <div class="dna-section">
                    <h3 class="dna-section-title">2025 Monthly Progress</h3>
                    <div class="monthly-chart" id="monthlyChart"></div>
                </div>
                
                <!-- Decades Preference -->
                <div class="dna-section">
                    <h3 class="dna-section-title">Decades Watched</h3>
                    <div class="decades-chart" id="decadesChart"></div>
                </div>
                
                <!-- Movie Timeline -->
                <div class="dna-section dna-wide">
                    <h3 class="dna-section-title">Recent Watch Timeline</h3>
                    <div class="timeline-chart" id="timelineChart">
                        <div class="timeline-empty">No movies with watch dates yet</div>
                    </div>
                </div>
            </div>
        </section>
        <!-- Placeholder for other sections -->
        <section style="padding: var(--space-4xl); text-align: center; background: var(--color-secondary-bg); border-radius: var(--radius-xl); border: 1px solid var(--color-border-light);">
            <h2>more profile sections coming soon...</h2>
            <p style="color: var(--color-text-secondary);">recent activity, trivia, etc.</p>
        </section>
    </main>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDDW8LtwpYevdkD7Q-_CxJ23mMfi00P21M",
            authDomain: "tiny-lizard.firebaseapp.com",
            projectId: "tiny-lizard",
            storageBucket: "tiny-lizard.firebasestorage.app",
            messagingSenderId: "250872474692",
            appId: "1:250872474692:web:969e0b1302ae3cb4666011"
        };
        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore(); 
        const auth = firebase.auth();

        let currentUser = null;
        let viewedUserId = null;
        let isEditingQuote = false;


        const BADGE_DEFINITIONS = [
        // Collection-Based
        {
            id: 'film_snob',
            emoji: '🎥',
            name: 'Film Snob',
            description: '20+ special/collector\'s editions',
            check: (data) => data.specialEditions >= 20
        },
        {
            id: 'new_age_baby',
            emoji: '💿',
            name: 'New Age Baby',
            description: '30+ Blu-rays in collection',
            check: (data) => data.blurayCount >= 30
        },
        {
            id: 'franchise_fanatic',
            emoji: '🎬',
            name: 'Franchise Fan',
            description: 'Complete 3+ movie franchises',
            check: (data) => data.completeFranchises >= 3
        },
        // Rating/Behavior-Based
        {
            id: 'harsh_critic',
            emoji: '😤',
            name: 'Harsh Critic',
            description: 'Average rating below 3.0',
            check: (data) => data.avgRating > 0 && data.avgRating < 3.0
        },
        {
            id: 'easy_please',
            emoji: '😊',
            name: 'Easy to Please',
            description: 'Average rating above 4.0',
            check: (data) => data.avgRating >= 4.0
        },
        {
            id: 'review_machine',
            emoji: '⭐',
            name: 'Review Machine',
            description: 'Written 50+ reviews',
            check: (data) => data.reviewCount >= 50
        },
        {
            id: 'worldly_viewer',
            emoji: '🌍',
            name: 'Worldly Viewer',
            description: 'Movies from 10+ countries',
            check: (data) => data.countryCount >= 10
        },
        // Time/Dedication-Based
        {
            id: 'opening_night',
            emoji: '🏆',
            name: 'Opening Night',
            description: 'Watched 5+ movies in release year',
            check: (data) => data.openingNightCount >= 5
        },
        {
            id: 'marathon_legend',
            emoji: '⏰',
            name: 'Marathon Legend',
            description: '100+ hours of watch time',
            check: (data) => data.totalHours >= 100
        }
    ];

        document.addEventListener('authStateReady', (e) => {
            currentUser = e.detail.user;
            const urlParams = new URLSearchParams(window.location.search);

            if (currentUser) {
                // If a user is logged in, determine which profile to show.
                // If no 'id' in URL, show the logged-in user's profile.
                viewedUserId = urlParams.get('id') || currentUser.uid;
                
                // Load the profile data for the determined user.
                loadProfileHeader(viewedUserId);
                
                // Preload the next page only if the user is viewing their own profile.
                if (viewedUserId === currentUser.uid) { 
                    preloadCollectionData(currentUser.uid);
                }
            } else {
                // Profile page requires a user, so redirect if not logged in.
                window.location.href = 'auth.html';
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            // This listener now only handles page-specific UI like quote editing.
            setupQuoteEditing();
        });

        async function loadProfileHeader(userId) {
            try {
                // Load user profile
                const userDoc = await db.collection('users').doc(userId).get();
                if (!userDoc.exists) {
                    throw new Error('User not found');
                }
                
                const userData = userDoc.data();
                
                // Update username
                document.getElementById('usernameDisplay').textContent = userData.displayName || 'Anonymous';
                
                // Update movie quote
                const quoteDisplay = document.getElementById('movieQuoteDisplay');
                if (userData.movieQuote && userData.movieQuote.trim()) {
                    quoteDisplay.textContent = `"${userData.movieQuote}"`;
                    quoteDisplay.classList.remove('empty');
                } else {
                    quoteDisplay.textContent = 'click to add your favorite movie quote...';
                    quoteDisplay.classList.add('empty');
                }
                
                // Load user's movie interactions
                const interactionsSnapshot = await db.collection('users').doc(userId).collection('movieInteractions').get();
                const interactions = interactionsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const movieData = await calculateAndDisplayStats(interactions, userId);

                // Load last watched movie
                await loadLastWatched(interactions);

                // Load MovieDNA Section
                await loadMovieDNA(interactions);

                // Load Badges
                await loadBadges(interactions, movieData);
                
            } catch (error) {
                console.error('Error loading profile header:', error);
                document.getElementById('usernameDisplay').textContent = 'Error loading profile';
            }
        }

        async function preloadCollectionData(userId) {
                try {
                    // Fetch and cache the collection data
                    const snapshot = await db.collection('users')
                        .doc(userId)
                        .collection('movieInteractions')
                        .where('owned', '==', true)
                        .get();
                    
                    if (!snapshot.empty) {
                        // Store in localStorage for the collection page to use
                        const CACHE_KEY = 'dvd_collection_cache';
                        const CACHE_EXPIRY_KEY = 'dvd_collection_cache_expiry';
                        const CACHE_DURATION = 30 * 60 * 1000;
                        
                        // Process the data (simplified version)
                        const movieIds = snapshot.docs.map(doc => doc.id);
                        const interactions = {};
                        snapshot.docs.forEach(doc => {
                            interactions[doc.id] = doc.data();
                        });
                        
                        // You could cache just the interactions for now
                        localStorage.setItem(CACHE_KEY + '_preview', JSON.stringify({
                            userId: userId,
                            movieIds: movieIds,
                            interactions: interactions,
                            timestamp: new Date().getTime()
                        }));
                        
                        console.log('Collection data pre-cached');
                    }
                } catch (error) {
                    console.error('Preload failed:', error);
                }
            }
            
        async function loadLastWatched(interactions) {
        // Filter for interactions that have a watchedDate
        const watchedInteractions = interactions.filter(i => 
            i.watchedDate && (typeof i.watchedDate === 'string' || i.watchedDate.seconds || i.watchedDate.toDate)
        );
        
        if (watchedInteractions.length === 0) {
            document.getElementById('lastWatchedSection').innerHTML = 
                '<div class="last-watched-empty">No movies watched yet</div>';
            return;
        }
        
        // Sort by watchedDate (most recent first)
        watchedInteractions.sort((a, b) => {
            let aTime = 0;
            let bTime = 0;
            
            // Handle string dates
            if (a.watchedDate) {
                if (typeof a.watchedDate === 'string') {
                    aTime = new Date(a.watchedDate).getTime() / 1000;
                } else {
                    aTime = a.watchedDate?.seconds || a.watchedDate?.toDate()?.getTime() / 1000 || 0;
                }
            }
            
            if (b.watchedDate) {
                if (typeof b.watchedDate === 'string') {
                    bTime = new Date(b.watchedDate).getTime() / 1000;
                } else {
                    bTime = b.watchedDate?.seconds || b.watchedDate?.toDate()?.getTime() / 1000 || 0;
                }
            }
            return bTime - aTime;
        });
        
        const lastWatched = watchedInteractions[0];
        const movieId = lastWatched.movieId || lastWatched.id; // Handle both formats
        
        try {
            // FIXED: Use CachedFirestore.getMovieByDocId instead of calling it directly
            const movieDoc = await CachedFirestore.getMovieByDocId(movieId);
            if (!movieDoc.exists) {
                document.getElementById('lastWatchedSection').innerHTML = 
                    '<div class="last-watched-empty">Last watched movie not found</div>';
                return;
            }
            
            const movieData = movieDoc.data();
            let watchedDate = null;
            
            if (lastWatched.watchedDate) {
                if (typeof lastWatched.watchedDate === 'string') {
                    // String date like "2025-07-27"
                    watchedDate = new Date(lastWatched.watchedDate);
                } else if (lastWatched.watchedDate.toDate) {
                    // Firestore Timestamp
                    watchedDate = lastWatched.watchedDate.toDate();
                } else if (lastWatched.watchedDate.seconds) {
                    // Firestore Timestamp object
                    watchedDate = new Date(lastWatched.watchedDate.seconds * 1000);
                }
            }
            
            const formattedDate = watchedDate ? watchedDate.toLocaleDateString() : 'Unknown date';

            document.getElementById('lastWatchedSection').innerHTML = `
                <img src="${movieData.posterUrl || 'https://placehold.co/60x90/2D194D/DEF0F7?text=N/A'}" 
                    class="last-watched-poster" 
                    alt="${movieData.title || 'Unknown Title'}"
                    loading="lazy"
                    onerror="this.src='https://placehold.co/60x90/2D194D/DEF0F7?text=N/A'">
                <div class="last-watched-info">
                    <h4>${movieData.title || 'Unknown Title'}</h4>
                    <p class="last-watched-date">Watched ${formattedDate}</p>
                </div>
            `;
        } catch (error) {
            console.error('Error loading last watched movie:', error);
            document.getElementById('lastWatchedSection').innerHTML = 
                '<div class="last-watched-empty">Error loading last watched</div>';
        }
    }
  
    // Enhanced calculateAndDisplayStats with favorites logic
    async function calculateAndDisplayStats(interactions, userId) {
        // Get movie data for interactions
        const movieIds = interactions.map(i => i.id);
        const movieData = {};
        
        if (movieIds.length > 0) {
            try {
                const moviePromises = [];
                for (let i = 0; i < movieIds.length; i += 10) {
                    const chunk = movieIds.slice(i, i + 10);
                    moviePromises.push(
                        db.collection('movies')
                        .where(firebase.firestore.FieldPath.documentId(), 'in', chunk)
                        .get()
                    );
                }
                
                const movieSnapshots = await Promise.all(moviePromises);
                movieSnapshots.forEach(snapshot => {
                    snapshot.forEach(doc => {
                        movieData[doc.id] = doc.data();
                    });
                });
            } catch (error) {
                console.error('Error fetching movie data:', error);
            }
        }
        
        // Calculate existing stats
        const ownedInteractions = interactions.filter(i => i.owned);
        const watchedInteractions = interactions.filter(i => 
            (i.watchedDate && (typeof i.watchedDate === 'string' || i.watchedDate.seconds || i.watchedDate.toDate)) || 
            i.watched === true
        );
        const ratedInteractions = interactions.filter(i => i.rating && i.rating > 0);
        
        // Count movies vs TV shows
        let movieCount = 0;
        let tvCount = 0;
        let totalHours = 0;
        
        ownedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie) {
                if (movie.contentType === 'tv') {
                    tvCount++;
                } else {
                    movieCount++;
                }
            }
        });
        
        const currentYear = 2025;
        watchedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.runtime && !isNaN(parseInt(movie.runtime))) {
                let dateToCheck = null;
                
                // Handle different date formats
                if (interaction.watchedDate) {
                    if (typeof interaction.watchedDate === 'string') {
                        // String date like "2025-07-27"
                        dateToCheck = new Date(interaction.watchedDate);
                    } else if (interaction.watchedDate.toDate) {
                        // Firestore Timestamp
                        dateToCheck = interaction.watchedDate.toDate();
                    } else if (interaction.watchedDate.seconds) {
                        // Firestore Timestamp object
                        dateToCheck = new Date(interaction.watchedDate.seconds * 1000);
                    }
                } else if (interaction.interactionDate) {
                    // Fall back to interactionDate
                    if (interaction.interactionDate.toDate) {
                        dateToCheck = interaction.interactionDate.toDate();
                    } else if (interaction.interactionDate.seconds) {
                        dateToCheck = new Date(interaction.interactionDate.seconds * 1000);
                    }
                }
                
                if (dateToCheck && !isNaN(dateToCheck.getTime()) && dateToCheck.getFullYear() === currentYear) {
                    totalHours += parseInt(movie.runtime);
                }
            }
        });
        totalHours = Math.round(totalHours / 60); // Convert to hours
        
        // Calculate average rating
        const avgRating = ratedInteractions.length > 0 
            ? (ratedInteractions.reduce((sum, i) => sum + i.rating, 0) / ratedInteractions.length).toFixed(1)
            : '-';
        
        // Calculate favorite directors
        const { favoriteDirectors, directorEligible } = calculateFavoriteDirectors(watchedInteractions, movieData);
        
        // Calculate favorite cast
        const { favoriteCast, castEligible } = calculateFavoriteCast(watchedInteractions, movieData);
        
        // Update display
        updateStatsDisplay({
            movieCount,
            tvCount,
            totalHours,
            avgRating,
            favoriteDirectors,
            favoriteCast,
            directorEligible,
            castEligible
        });

        return movieData;
    }

    function setupQuoteEditing() {
        const quoteDisplay = document.getElementById('movieQuoteDisplay');
        const quoteInput = document.getElementById('movieQuoteInput');
        const editActions = document.getElementById('quoteEditActions');
        const saveBtn = document.getElementById('saveQuoteBtn');
        const cancelBtn = document.getElementById('cancelQuoteBtn');
        
        // Only allow editing if viewing own profile
        quoteDisplay.addEventListener('click', () => {
            if (currentUser && currentUser.uid === viewedUserId && !isEditingQuote) {
                startQuoteEdit();
            }
        });
        
        saveBtn.addEventListener('click', saveQuote);
        cancelBtn.addEventListener('click', cancelQuoteEdit);
        
        // Save on Enter, cancel on Escape
        quoteInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveQuote();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                cancelQuoteEdit();
            }
        });
    }
    function startQuoteEdit() {
        const quoteDisplay = document.getElementById('movieQuoteDisplay');
        const quoteInput = document.getElementById('movieQuoteInput');
        const editActions = document.getElementById('quoteEditActions');
        
        isEditingQuote = true;
        
        // Get current quote text (remove quotes if present)
        let currentText = quoteDisplay.textContent;
        if (currentText === 'Click to add your favorite movie quote...') {
            currentText = '';
        } else if (currentText.startsWith('"') && currentText.endsWith('"')) {
            currentText = currentText.slice(1, -1);
        }
        
        quoteInput.value = currentText;
        quoteDisplay.style.display = 'none';
        quoteInput.style.display = 'block';
        editActions.classList.add('active');
        quoteInput.focus();
    }
    async function saveQuote() {
        const quoteInput = document.getElementById('movieQuoteInput');
        const newQuote = quoteInput.value.trim();
        
        try {
            // Update Firestore
            await db.collection('users').doc(currentUser.uid).update({
                movieQuote: newQuote
            });
            
            // Update display
            const quoteDisplay = document.getElementById('movieQuoteDisplay');
            if (newQuote) {
                quoteDisplay.textContent = `"${newQuote}"`;
                quoteDisplay.classList.remove('empty');
            } else {
                quoteDisplay.textContent = 'Click to add your favorite movie quote...';
                quoteDisplay.classList.add('empty');
            }
            
            cancelQuoteEdit();
            
        } catch (error) {
            console.error('Error saving quote:', error);
            alert('Failed to save quote. Please try again.');
        }
    }
    function cancelQuoteEdit() {
        const quoteDisplay = document.getElementById('movieQuoteDisplay');
        const quoteInput = document.getElementById('movieQuoteInput');
        const editActions = document.getElementById('quoteEditActions');
        
        isEditingQuote = false;
        quoteDisplay.style.display = 'flex';
        quoteInput.style.display = 'none';
        editActions.classList.remove('active');
    }
    async function loadBadges(interactions, movieData) {
        // Calculate badge data
        const badgeData = calculateBadgeData(interactions, movieData);
        
        // Display badges
        displayBadges(badgeData);
    }

    function calculateBadgeData(interactions, movieData) {
        const ownedInteractions = interactions.filter(i => i.owned);
        const watchedInteractions = interactions.filter(i => 
            i.watchedDate && (typeof i.watchedDate === 'string' || i.watchedDate.seconds || i.watchedDate.toDate)
        );
        const ratedInteractions = interactions.filter(i => i.rating && i.rating > 0);
        const reviewedInteractions = interactions.filter(i => i.review && i.review.trim());
        
        // Genre counts
        const genreCounts = {};
        ownedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.genres && Array.isArray(movie.genres)) {
                movie.genres.forEach(genre => {
                    if (genre && genre.trim()) {
                        genreCounts[genre] = (genreCounts[genre] || 0) + 1;
                    }
                });
            }
        });
        
        // Special editions count
        const specialEditions = ownedInteractions.filter(interaction => {
            const edition = interaction.editionDetails || '';
            return edition.toLowerCase().includes('special') || 
                edition.toLowerCase().includes('collector') || 
                edition.toLowerCase().includes('criterion') ||
                edition.toLowerCase().includes('anniversary') ||
                edition.toLowerCase().includes('limited');
        }).length;
        
        // Blu-ray count
        const blurayCount = ownedInteractions.filter(interaction => {
            const format = interaction.format || '';
            return format.toLowerCase().includes('blu') || format.toLowerCase().includes('4k');
        }).length;
        
        // Country count
        const countries = new Set();
        ownedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.country) {
                countries.add(movie.country);
            }
        });
        
        // Opening night count (watched in release year)
        const openingNightCount = watchedInteractions.filter(interaction => {
            const movie = movieData[interaction.id];
            if (!movie || !movie.releaseDate) return false;
            
            const releaseYear = parseInt(movie.releaseDate.substring(0, 4));
            let watchDate = null;
            
            if (typeof interaction.watchedDate === 'string') {
                watchDate = new Date(interaction.watchedDate);
            } else if (interaction.watchedDate.toDate) {
                watchDate = interaction.watchedDate.toDate();
            } else if (interaction.watchedDate.seconds) {
                watchDate = new Date(interaction.watchedDate.seconds * 1000);
            }
            
            return watchDate && watchDate.getFullYear() === releaseYear;
        }).length;
        
        // Calculate total hours
        let totalHours = 0;
        watchedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.runtime && !isNaN(parseInt(movie.runtime))) {
                totalHours += parseInt(movie.runtime);
            }
        });
        totalHours = Math.round(totalHours / 60);
        
        // Calculate average rating
        const avgRating = ratedInteractions.length > 0 
            ? ratedInteractions.reduce((sum, i) => sum + i.rating, 0) / ratedInteractions.length
            : 0;
        
        return {
            genreCounts,
            specialEditions,
            blurayCount,
            completeFranchises: 0, // This would need franchise detection logic
            avgRating,
            reviewCount: reviewedInteractions.length,
            countryCount: countries.size,
            openingNightCount,
            totalHours
        };
    }

    function displayBadges(badgeData) {
        const badgesGrid = document.getElementById('badgesGrid');
        let badgesHTML = '';
        
        // First, add genre expert badges dynamically
        Object.entries(badgeData.genreCounts).forEach(([genre, count]) => {
            if (count >= 30) {
                badgesHTML += `
                    <div class="badge-item earned">
                        <div class="badge-emoji">🎭</div>
                        <div class="badge-name">${genre} Expert</div>
                        <div class="badge-tooltip">30+ ${genre} movies in collection (${count})</div>
                    </div>
                `;
            }
        });
        // Show the top unearned genre (closest to 30) if no genres are at 30+
        const hasGenreExpert = Object.values(badgeData.genreCounts).some(count => count >= 30);
        if (!hasGenreExpert) {
            const topGenre = Object.entries(badgeData.genreCounts)
                .sort((a, b) => b[1] - a[1])[0];
            
            if (topGenre) {
                const [genre, count] = topGenre;
                badgesHTML += `
                    <div class="badge-item not-earned">
                        <div class="badge-emoji">🎭</div>
                        <div class="badge-name">${genre} Expert</div>
                        <div class="badge-tooltip">Need ${30 - count} more ${genre} movies (${count}/30)</div>
                    </div>
                `;
            }
        }

        // Then add all the regular badges
        BADGE_DEFINITIONS.forEach(badge => {
            const earned = badge.check(badgeData);
            
            badgesHTML += `
                <div class="badge-item ${earned ? 'earned' : 'not-earned'}">
                    <div class="badge-emoji">${badge.emoji}</div>
                    <div class="badge-name">${badge.name}</div>
                    <div class="badge-tooltip">${badge.description}</div>
                </div>
            `;
        });
        
        badgesGrid.innerHTML = badgesHTML;
    }
    // Helper function to calculate favorite directors
    function calculateFavoriteDirectors(watchedInteractions, movieData) {
        const directorCounts = {};
        let eligibleMovies = 0;
        
        watchedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.director && movie.director.trim()) {
                eligibleMovies++;
                const director = movie.director.trim();
                directorCounts[director] = (directorCounts[director] || 0) + 1;
            }
        });
        
        if (eligibleMovies < 5) {
            return {
                favoriteDirectors: `Need ${5 - eligibleMovies} more`,
                directorEligible: false
            };
        }
        
        const topDirectors = Object.entries(directorCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([director, count]) => count > 1 ? `${director} (${count})` : director);
        
        return {
            favoriteDirectors: topDirectors.length > 0 ? topDirectors.join(', ') : 'No favorites yet',
            directorEligible: true
        };
    }

    // Helper function to calculate favorite cast
    function calculateFavoriteCast(watchedInteractions, movieData) {
        const castCounts = {};
        let eligibleMovies = 0;
        
        watchedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.cast && Array.isArray(movie.cast) && movie.cast.length > 0) {
                eligibleMovies++;
                movie.cast.forEach(actor => {
                    if (actor && typeof actor === 'string' && actor.trim()) {
                        const actorName = actor.trim();
                        castCounts[actorName] = (castCounts[actorName] || 0) + 1;
                    }
                });
            }
        });
        
        if (eligibleMovies < 5) {
            return {
                favoriteCast: `Need ${5 - eligibleMovies} more`,
                castEligible: false
            };
        }
        
        const topCast = Object.entries(castCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([actor, count]) => count > 1 ? `${actor} (${count})` : actor);
        
        return {
            favoriteCast: topCast.length > 0 ? topCast.join(', ') : 'No favorites yet',
            castEligible: true
        };
    }
   
    // Helper function to update stats display
    function updateStatsDisplay(stats) {
        // Update existing stats
        const elements = {
            totalMoviesCount: stats.movieCount,
            totalTVCount: stats.tvCount,
            hoursWatchedCount: stats.totalHours,
            avgRatingDisplay: stats.avgRating
        };
        
        Object.entries(elements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        });
    
        // Update favorite directors
        const favoriteDirectorsEl = document.getElementById('favoriteDirectorsDisplay');
        if (favoriteDirectorsEl) {
            favoriteDirectorsEl.textContent = stats.favoriteDirectors;
            if (!stats.directorEligible) {
                favoriteDirectorsEl.classList.add('insufficient-data');
                favoriteDirectorsEl.title = 'Watch 5+ movies with director info to see favorites';
            } else {
                favoriteDirectorsEl.classList.remove('insufficient-data');
                favoriteDirectorsEl.title = stats.favoriteDirectors;
            }
        }
    
        // Update favorite cast
        const favoriteCastEl = document.getElementById('favoriteCastDisplay');
        if (favoriteCastEl) {
            favoriteCastEl.textContent = stats.favoriteCast;
            if (!stats.castEligible) {
                favoriteCastEl.classList.add('insufficient-data');
                favoriteCastEl.title = 'Watch 5+ movies with cast info to see favorites';
            } else {
                favoriteCastEl.classList.remove('insufficient-data');
                favoriteCastEl.title = stats.favoriteCast;
            }
        }
    }

    // Helper function for error states
    function showErrorState() {
        const statsElements = [
            'totalMoviesCount', 'totalTVCount', 'hoursWatchedCount', 
            'avgRatingDisplay', 'favoriteDirectorsDisplay', 'favoriteCastDisplay'
        ];
        
        statsElements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = 'Error';
                element.classList.add('insufficient-data');
            }
        });
        
        document.getElementById('lastWatchedSection').innerHTML = 
            '<div class="last-watched-empty">Error loading data</div>';
    }
  
    async function loadMovieDNA(interactions) {
        // Get movie data for interactions with watchedDate
        const watchedInteractions = interactions.filter(i => 
            i.watchedDate && (typeof i.watchedDate === 'string' || i.watchedDate.seconds || i.watchedDate.toDate)
        );
        
        if (watchedInteractions.length === 0) {
            showEmptyDNA();
            return;
        }
        
        // Get movie data
        const movieIds = watchedInteractions.map(i => i.id);
        const movieData = {};
        
        if (movieIds.length > 0) {
            try {
                const moviePromises = [];
                for (let i = 0; i < movieIds.length; i += 10) {
                    const chunk = movieIds.slice(i, i + 10);
                    moviePromises.push(
                        db.collection('movies')
                        .where(firebase.firestore.FieldPath.documentId(), 'in', chunk)
                        .get()
                    );
                }
                
                const movieSnapshots = await Promise.all(moviePromises);
                movieSnapshots.forEach(snapshot => {
                    snapshot.forEach(doc => {
                        movieData[doc.id] = doc.data();
                    });
                });
            } catch (error) {
                console.error('Error fetching movie data for DNA:', error);
                return;
            }
        }
        
        // Calculate and display each DNA section
        displayGenreBreakdown(watchedInteractions, movieData);
        displayMonthlyProgress(watchedInteractions);
        displayDecadesPreference(watchedInteractions, movieData);
        displayWatchTimeline(watchedInteractions, movieData);
    }

    function displayGenreBreakdown(watchedInteractions, movieData) {
        const genreCounts = {};
        
        watchedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.genres && Array.isArray(movie.genres)) {
                movie.genres.forEach(genre => {
                    if (genre && genre.trim()) {
                        genreCounts[genre] = (genreCounts[genre] || 0) + 1;
                    }
                });
            }
        });
        
        const sortedGenres = Object.entries(genreCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
        
        if (sortedGenres.length === 0) {
            document.getElementById('genreLegend').innerHTML = '<div class="legend-item">No genre data available</div>';
            return;
        }
        
        const colors = ['#00FFFF', '#fdfb76', '#00db96', '#e10086', '#90dcff'];
        let legendHTML = '';
        
        sortedGenres.forEach(([genre, count], index) => {
            legendHTML += `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${colors[index]}"></div>
                    <span class="legend-text">${genre}</span>
                    <span class="legend-count">${count}</span>
                </div>
            `;
        });
        
        document.getElementById('genreLegend').innerHTML = legendHTML;
    }

    function displayMonthlyProgress(watchedInteractions) {
        const monthCounts = new Array(12).fill(0);
        const monthNames = ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'];
        
        watchedInteractions.forEach(interaction => {
            let watchDate = null;
            if (typeof interaction.watchedDate === 'string') {
                watchDate = new Date(interaction.watchedDate);
            } else if (interaction.watchedDate.toDate) {
                watchDate = interaction.watchedDate.toDate();
            } else if (interaction.watchedDate.seconds) {
                watchDate = new Date(interaction.watchedDate.seconds * 1000);
            }
            
            if (watchDate && watchDate.getFullYear() === 2025) {
                monthCounts[watchDate.getMonth()]++;
            }
        });
        
        const maxCount = Math.max(...monthCounts, 1);
        let chartHTML = '';
        
        monthCounts.forEach((count, index) => {
            const height = (count / maxCount) * 100;
            chartHTML += `
                <div class="month-bar" 
                    style="height: ${height}%" 
                    data-month="${monthNames[index]}"
                    data-count="${count}">
                </div>
            `;
        });
        
        document.getElementById('monthlyChart').innerHTML = chartHTML;
    }

    function displayDecadesPreference(watchedInteractions, movieData) {
        const decadeCounts = {};
        
        watchedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (movie && movie.releaseDate) {
                const year = parseInt(movie.releaseDate.substring(0, 4));
                if (!isNaN(year)) {
                    const decade = Math.floor(year / 10) * 10;
                    decadeCounts[decade] = (decadeCounts[decade] || 0) + 1;
                }
            }
        });
        
        const sortedDecades = Object.entries(decadeCounts)
            .sort((a, b) => parseInt(b[0]) - parseInt(a[0]))
            .slice(0, 6);
        
        if (sortedDecades.length === 0) {
            document.getElementById('decadesChart').innerHTML = '<div style="text-align: center; color: var(--color-text-muted);">No decade data available</div>';
            return;
        }
        
        const maxCount = Math.max(...sortedDecades.map(([_, count]) => count));
        let chartHTML = '';
        
        sortedDecades.forEach(([decade, count]) => {
            const width = (count / maxCount) * 100;
            chartHTML += `
                <div class="decade-bar-container">
                    <div class="decade-label">${decade}s</div>
                    <div class="decade-bar-track">
                        <div class="decade-bar-fill" style="width: ${width}%"></div>
                    </div>
                    <div class="decade-count">${count}</div>
                </div>
            `;
        });
        
        document.getElementById('decadesChart').innerHTML = chartHTML;
    }

    function displayWatchTimeline(watchedInteractions, movieData) {
        // Group by month
        const monthlyMovies = {};
        
        watchedInteractions.forEach(interaction => {
            const movie = movieData[interaction.id];
            if (!movie) return;
            
            let watchDate = null;
            if (typeof interaction.watchedDate === 'string') {
                watchDate = new Date(interaction.watchedDate);
            } else if (interaction.watchedDate.toDate) {
                watchDate = interaction.watchedDate.toDate();
            } else if (interaction.watchedDate.seconds) {
                watchDate = new Date(interaction.watchedDate.seconds * 1000);
            }
            
            if (watchDate && watchDate.getFullYear() === 2025) {
                const monthKey = `${watchDate.getFullYear()}-${String(watchDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyMovies[monthKey]) {
                    monthlyMovies[monthKey] = [];
                }
                monthlyMovies[monthKey].push({
                    title: movie.title,
                    date: watchDate
                });
            }
        });
        
        if (Object.keys(monthlyMovies).length === 0) {
            return; // Keep the empty state
        }
        
        // Sort months by date (most recent first)
        const sortedMonths = Object.entries(monthlyMovies)
            .sort((a, b) => b[0].localeCompare(a[0]))
            .slice(0, 6); // Show last 6 months
        
        let timelineHTML = '<div class="timeline-container">';
        
        sortedMonths.forEach(([monthKey, movies]) => {
            const [year, month] = monthKey.split('-');
            const monthName = new Date(parseInt(year), parseInt(month) - 1).toLocaleDateString('en', { month: 'short', year: 'numeric' });
            
            // Sort movies by date within month
            movies.sort((a, b) => b.date - a.date);
            
            timelineHTML += `
                <div class="timeline-month">
                    <div class="timeline-month-label">${monthName}</div>
                    <div class="timeline-movies">
            `;
            
            movies.forEach(movie => {
                timelineHTML += `
                    <div class="timeline-movie" data-title="${movie.title}"></div>
                `;
            });
            
            timelineHTML += `
                    </div>
                </div>
            `;
        });
        
        timelineHTML += '</div>';
        document.getElementById('timelineChart').innerHTML = timelineHTML;
    }

    function showEmptyDNA() {
        document.getElementById('genreLegend').innerHTML = '<div class="legend-item">No watched movies with dates yet</div>';
        document.getElementById('monthlyChart').innerHTML = '<div style="text-align: center; color: var(--color-text-muted); padding: var(--space-xl);">No data for 2025</div>';
        document.getElementById('decadesChart').innerHTML = '<div style="text-align: center; color: var(--color-text-muted);">No decade data available</div>';
        // Timeline keeps its empty state
    }
  </script>
    <footer id="footer-placeholder"></footer>
</body>
</html>