<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Details - The Library Sale</title>
    <!-- Google Fonts & Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=B612+Mono&family=Dokdo&family=Kirang+Haerang&family=M+PLUS+2&family=Syne+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-auth-compat.js"></script>   
    <!-- App Utilities & Main Script -->
    <script src="utils.js" defer></script>
    <script src="main.js" defer></script>
<body>
    <header id="navbar-placeholder"></header>

    <div id="detailsContainer" class="details-page-container" style="display: none;">
        
        <!-- Centered Title, Year, and Ratings (Ticket Style) -->
        <div class="details-ticket">
            <h1 id="movieTitle" class="details-title"></h1>
            <p id="movieYear" class="details-year"></p>
            
            <!-- Ratings Section - Stars Only -->
            <div class="details-ratings">
                <div class="rating-box">
                    <h3>Average Rating</h3>
                    <div id="averageRating" class="media-rating"></div>
                </div>
                <div class="rating-box">
                    <h3>My Rating</h3>
                    <div id="myRating" class="media-rating"></div>
                </div>
            </div>
        </div>

        <!-- Main Content Grid (Poster + Info) -->
        <div class="details-main-content">
            <div class="details-poster">
                <img id="moviePoster" src="" alt="Movie Poster">
            </div>
            <div class="details-info">
                <div class="details-info-group">
                    <h3>Director</h3>
                    <p id="movieDirector"></p>
                </div>
                <div class="details-info-group">
                    <h3>Top Cast</h3>
                    <p id="movieCast"></p>
                </div>
                <div class="details-info-group">
                    <h3>Genre</h3>
                    <p id="movieGenre"></p>
                </div>
            </div>
        </div>

        <!-- Summary Section -->
        <div class="details-summary-section">
            <h2 class="details-summary-header">
                <span class="icon"></span>
                Summary
            </h2>
            <div class="details-summary" id="summaryGroup">
                <p id="movieOverview" class="summary-text"></p>
                <button id="readMoreBtn" class="read-more-btn" style="display: none;">Read more</button>
            </div>
        </div>

        <!-- Comments Section -->
        <div class="comments-section">
            <div class="comments-header">
                <div class="comments-title">
                    <span class="icon"></span>
                    Comments
                </div>
                <div>
                    <button id="addCommentBtn" class="btn-add-comment">Add Comment</button>
                    <button id="editCommentBtn" class="btn-edit-comment" style="display: none;">Edit Comment</button>
                </div>
            </div>
            
            <!-- Comment Edit Form (hidden by default) -->
            <div id="commentEditForm" class="comment-edit-form">
                <textarea id="commentEditTextarea" class="comment-edit-textarea" placeholder="Share your thoughts about this movie..."></textarea>
                <div class="comment-edit-actions">
                    <button id="saveCommentBtn" class="btn-comment-save" title="Save Comment"></button>
                    <button id="cancelCommentBtn" class="btn-comment-cancel" title="Cancel"></button>
                </div>
            </div>
            
            <div id="commentsContainer" class="comments-list">
                <!-- Comments will be injected by JS -->
            </div>
        </div>

        <!-- Physical Copies Section -->
        <div class="physical-copies-section">
            <h2 class="physical-copies-header">
                <span class="icon"></span>
                Physical Copies
            </h2>
            <div id="physicalCopiesContainer" class="physical-copies-list">
                <!-- Physical copies will be injected by JS -->
            </div>
        </div>

        <!-- Footer with Back Button -->
        <footer class="details-footer">
            <a href="index.html" class="btn-back"></a>
        </footer>
    </div>

    <!-- Loading and Error States -->
    <div id="loadingState" class="main-container" style="text-align: center; padding: 50px;">
        <h2>Loading...</h2>
    </div>
    <div id="errorState" class="main-container" style="display: none; text-align: center; padding: 50px;">
        <h2 id="errorMessage"></h2>
        <a href="index.html" class="btn-back" style="margin-top: 20px;"></a>
    </div>

<script>
    // --- FIREBASE INITIALIZATION ---
    const firebaseConfig = {
        apiKey: "AIzaSyDDW8LtwpYevdkD7Q-_CxJ23mMfi00P21M",
        authDomain: "tiny-lizard.firebaseapp.com",
        projectId: "tiny-lizard",
        storageBucket: "tiny-lizard.firebasestorage.app",
        messagingSenderId: "250872474692",
        appId: "1:250872474692:web:969e0b1302ae3cb4666011"
    };
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore(); 
    const auth = firebase.auth();

    async function loadMoviePage(user, movieId) {
        try {
            console.log('=== DEBUG: Loading movie page ===');
            console.log('User:', user?.uid);
            console.log('Movie ID:', movieId);

            // Get the main movie document
            const movieDocRef = db.collection('movies').doc(movieId);
            const movieDoc = await movieDocRef.get();

            if (!movieDoc.exists) {
                throw new Error("This movie could not be found in the main library.");
            }
            const movieData = { id: movieDoc.id, ...movieDoc.data() };
            console.log('Movie data loaded:', movieData.title);

            // Get interactions for this movie
            const interactionsSnapshot = await db.collectionGroup('movieInteractions')
                .where('movieId', '==', movieId)
                .get();
            
            console.log('Found interactions for this movie:', interactionsSnapshot.size);
            
            const allInteractions = interactionsSnapshot.docs.map(doc => {
                const pathParts = doc.ref.path.split('/');
                const userId = pathParts[1]; 
                const data = doc.data();
                console.log('Processing interaction:', { userId, movieId: data.movieId, hasReview: !!data.review });
                return { userId: userId, ...data };
            });
            
            // Find the current user's specific interaction
            const myInteraction = allInteractions.find(interaction => interaction.userId === user.uid);
            console.log('My interaction:', myInteraction);

            // Populate page content
            populateMovieDetails(movieData, myInteraction, allInteractions);
            await loadCommentsWithUserData(allInteractions);
            await loadPhysicalCopies(allInteractions, movieId);
            setupCommentForm(user, movieId, myInteraction);

            // Show the content
            const loadingState = document.getElementById('loadingState');
            const detailsContainer = document.getElementById('detailsContainer');
            
            if (loadingState) loadingState.style.display = 'none';
            if (detailsContainer) detailsContainer.style.display = 'block';

        } catch (error) {
            console.error("Error loading movie page:", error);
            displayError(error.message || "An unknown error occurred.");
        }
    }

    function populateMovieDetails(movieData, myInteraction, allInteractions) {
        document.getElementById('movieTitle').textContent = movieData.title || 'Untitled';
        document.getElementById('movieYear').textContent = movieData.year || 'N/A';
        document.getElementById('moviePoster').src = movieData.posterUrl || 'https://placehold.co/300x450/1a1a1a/4a4a4a?text=No+Poster';
        document.getElementById('moviePoster').alt = `Poster for ${movieData.title}`;
        document.getElementById('movieDirector').textContent = movieData.director || 'N/A';
        document.getElementById('movieCast').textContent = Array.isArray(movieData.cast) ? movieData.cast.join(', ') : 'N/A';
        document.getElementById('movieGenre').textContent = movieData.genre || 'N/A';
        
        // Handle summary with read more functionality
        const overviewElement = document.getElementById('movieOverview');
        const readMoreBtn = document.getElementById('readMoreBtn');
        const summaryGroup = document.getElementById('summaryGroup');
        const overview = movieData.overview || 'No description available.';
        
        overviewElement.textContent = overview;
        
        // Check if text is longer than 3 lines (approximate)
        if (overview.length > 200) {
            summaryGroup.classList.add('collapsed');
            readMoreBtn.style.display = 'block';
            readMoreBtn.textContent = 'Read more';
            
            readMoreBtn.onclick = function() {
                if (summaryGroup.classList.contains('collapsed')) {
                    summaryGroup.classList.remove('collapsed');
                    readMoreBtn.textContent = 'Read less';
                } else {
                    summaryGroup.classList.add('collapsed');
                    readMoreBtn.textContent = 'Read more';
                }
            };
        }

        // Calculate average rating from all fetched interactions
        const ratings = allInteractions.map(i => i.rating).filter(r => r > 0);
        const avgRating = ratings.length > 0 ? ratings.reduce((a, b) => a + b, 0) / ratings.length : null;

        renderStars(document.getElementById('averageRating'), avgRating); 
        renderStars(document.getElementById('myRating'), myInteraction ? myInteraction.rating : 0);
    }

    async function loadCommentsWithUserData(interactions) {
        console.log('=== DEBUG: Loading comments ===');
        console.log('All interactions:', interactions);
        
        const commentsContainer = document.getElementById('commentsContainer');
        if (!commentsContainer) {
            console.error('Comments container not found');
            return;
        }
        
        commentsContainer.innerHTML = '';

        // Filter for interactions that have reviews
        const commentsWithReviews = interactions.filter(i => {
            const hasReview = i.review && i.review.trim() !== '';
            console.log('Checking review for user', i.userId, ':', hasReview, i.review);
            return hasReview;
        });
        
        console.log('Comments with reviews:', commentsWithReviews);

        if (commentsWithReviews.length === 0) {
            commentsContainer.innerHTML = `<p class="review-text-empty">No comments yet. Be the first to leave a review!</p>`;
            return;
        }

        // Get unique user IDs to fetch display names
        const userIds = [...new Set(commentsWithReviews.map(c => c.userId))];
        console.log('Fetching user data for:', userIds);
        
        // Fetch user profiles
        const userPromises = userIds.map(async id => {
            try {
                const userDoc = await db.collection('users').doc(id).get();
                const userData = {
                    id: id,
                    displayName: userDoc.exists ? userDoc.data().displayName : 'Anonymous'
                };
                console.log('User data fetched:', userData);
                return userData;
            } catch (error) {
                console.error(`Error fetching user ${id}:`, error);
                return { id: id, displayName: 'Anonymous' };
            }
        });
        
        const userData = await Promise.all(userPromises);
        
        // Create a map for easy lookup
        const userMap = new Map();
        userData.forEach(user => {
            userMap.set(user.id, user.displayName);
        });

        // Render comments
        commentsWithReviews.forEach(comment => {
            const username = userMap.get(comment.userId) || 'Anonymous';
            const commentEl = document.createElement('div');
            commentEl.className = 'comment-item';
            commentEl.innerHTML = `
                <p class="review-text">${comment.review}</p>
                <p class="comment-author">by <a href="profile.html?id=${comment.userId}">${username}</a></p>
            `;
            commentsContainer.appendChild(commentEl);
        });
        
        console.log('=== DEBUG: Comments rendered ===');
    }

    async function loadPhysicalCopies(interactions, movieId) {
        console.log('=== DEBUG: Loading physical copies ===');
        
        const physicalCopiesContainer = document.getElementById('physicalCopiesContainer');
        if (!physicalCopiesContainer) {
            console.error('Physical copies container not found');
            return;
        }
        
        physicalCopiesContainer.innerHTML = '';

        // Filter for interactions where the user owns a physical copy
        const physicalCopies = interactions.filter(i => i.owned === true);
        
        console.log('Physical copies found:', physicalCopies);

        if (physicalCopies.length === 0) {
            physicalCopiesContainer.innerHTML = `<p class="no-physical-copies">No physical copies tracked yet.</p>`;
            return;
        }

        // Get unique user IDs to fetch display names
        const userIds = [...new Set(physicalCopies.map(c => c.userId))];
        console.log('Fetching user data for physical copies:', userIds);
        
        // Fetch user profiles
        const userPromises = userIds.map(async id => {
            try {
                const userDoc = await db.collection('users').doc(id).get();
                const userData = {
                    id: id,
                    displayName: userDoc.exists ? userDoc.data().displayName : 'Anonymous'
                };
                return userData;
            } catch (error) {
                console.error(`Error fetching user ${id}:`, error);
                return { id: id, displayName: 'Anonymous' };
            }
        });
        
        const userData = await Promise.all(userPromises);
        
        // Create a map for easy lookup
        const userMap = new Map();
        userData.forEach(user => {
            userMap.set(user.id, user.displayName);
        });

        // Render physical copies
        physicalCopies.forEach(copy => {
            const username = userMap.get(copy.userId) || 'Anonymous';
            const copyEl = document.createElement('div');
            copyEl.className = 'physical-copy-item';
            
            // Build edition details string from the interaction data
            let editionText = 'Physical copy';
            
            // First priority: use the raw editionDetails if available
            if (copy.editionDetails && copy.editionDetails.trim()) {
                editionText = copy.editionDetails.trim();
            } else {
                // Fallback: build from structured fields
                let editionParts = [];
                
                if (copy.format) editionParts.push(copy.format);
                if (copy.condition) editionParts.push(`Condition: ${copy.condition}`);
                if (copy.region) editionParts.push(copy.region);
                if (copy.specialFeatures && copy.specialFeatures.length > 0) {
                    editionParts.push(`Features: ${copy.specialFeatures.join(', ')}`);
                }
                
                if (editionParts.length > 0) {
                    editionText = editionParts.join(' • ');
                }
            }
            
            copyEl.innerHTML = `
                <div class="copy-edition-details">${editionText}</div>
                <div class="copy-owner">
                    by <a href="profile.html?id=${copy.userId}">${username}</a>
                </div>
            `;
            physicalCopiesContainer.appendChild(copyEl);
        });
        
        console.log('=== DEBUG: Physical copies rendered ===');
    }

    function renderStars(container, rating) {
        if (!container) return;
        
        container.innerHTML = '';
        if (typeof rating !== 'number' || rating <= 0) {
            container.innerHTML = `<span class="not-rated">Not Rated</span>`;
            return;
        }
        let starsHTML = '';
        for (let i = 1; i <= 5; i++) {
            if (i <= rating) starsHTML += `<span class="star star-full"></span>`;
            else if (i - 0.5 <= rating) starsHTML += `<span class="star star-half"></span>`;
            else starsHTML += `<span class="star star-empty"></span>`;
        }
        // Removed rating text - only stars now
        container.innerHTML = starsHTML;
    }

    function displayError(message) {
        const loadingState = document.getElementById('loadingState');
        const errorState = document.getElementById('errorState');
        const errorMessage = document.getElementById('errorMessage');
        
        if (loadingState) loadingState.style.display = 'none';
        if (errorState) errorState.style.display = 'block';
        if (errorMessage) errorMessage.textContent = message;
    }

    // Set up event listeners after DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        auth.onAuthStateChanged(user => {
            if (user) {
                const movieId = new URLSearchParams(window.location.search).get('id');
                if (movieId) {
                    loadMoviePage(user, movieId);
                } else {
                    displayError("No movie was selected. Please return to the library.");
                }
            } else {
                window.location.href = 'auth.html';
            }
        });
    });

    // Comment form functionality
    function setupCommentForm(user, movieId, myInteraction) {
        const addCommentBtn = document.getElementById('addCommentBtn');
        const commentEditForm = document.getElementById('commentEditForm');
        const commentTextarea = document.getElementById('commentEditTextarea');
        const saveCommentBtn = document.getElementById('saveCommentBtn');
        const cancelCommentBtn = document.getElementById('cancelCommentBtn');

        // Check if user already has a comment
        const existingReview = myInteraction?.review || '';
        const isEditing = existingReview.trim() !== '';

        // Update button text based on whether user has existing comment
        if (isEditing) {
        editCommentBtn.style.display = 'inline-flex';
        addCommentBtn.style.display = 'none';
        } else {
            addCommentBtn.style.display = 'inline-flex';
            editCommentBtn.style.display = 'none';
        }

        // Show/hide comment form
        addCommentBtn.addEventListener('click', () => {
            commentEditForm.style.display = 'block';
            addCommentBtn.style.display = 'none';
            commentTextarea.value = existingReview;
            commentTextarea.focus();
        });

        // Cancel comment editing
        cancelCommentBtn.addEventListener('click', () => {
            commentEditForm.style.display = 'none';
            addCommentBtn.style.display = 'inline-flex';
            commentTextarea.value = '';
        });

        // Save comment
        saveCommentBtn.addEventListener('click', async () => {
            const newReview = commentTextarea.value.trim();
            
            if (newReview === '') {
                alert('Please enter a comment before saving.');
                return;
            }

            try {
                // Disable save button to prevent double-clicking
                saveCommentBtn.disabled = true;
                saveCommentBtn.style.opacity = '0.5';

                // Update or create user interaction with the new review
                const interactionData = {
                    movieId: movieId,
                    review: newReview,
                    interactionDate: firebase.firestore.FieldValue.serverTimestamp(),
                    // Preserve existing data if user already has an interaction
                    ...(myInteraction && {
                        rating: myInteraction.rating || 0,
                        watched: myInteraction.watched || false,
                        watchedDate: myInteraction.watchedDate || null,
                        owned: myInteraction.owned || false,
                        editionDetails: myInteraction.editionDetails || null,
                        format: myInteraction.format || null,
                        condition: myInteraction.condition || null,
                        region: myInteraction.region || null,
                        specialFeatures: myInteraction.specialFeatures || []
                    })
                };

                await db.collection('users').doc(user.uid).collection('movieInteractions').doc(movieId).set(interactionData, { merge: true });

                // Hide form and show success
                commentEditForm.style.display = 'none';
                addCommentBtn.style.display = 'inline-flex';
                addCommentBtn.textContent = 'Edit Comment';
                commentTextarea.value = '';

                // Reload comments to show the update
                const interactionsSnapshot = await db.collectionGroup('movieInteractions')
                    .where('movieId', '==', movieId)
                    .get();
                
                const allInteractions = interactionsSnapshot.docs.map(doc => {
                    const pathParts = doc.ref.path.split('/');
                    const userId = pathParts[1]; 
                    const data = doc.data();
                    return { userId: userId, ...data };
                });

                await loadCommentsWithUserData(allInteractions);
                
                // Show success message briefly
                const successMsg = document.createElement('div');
                successMsg.className = 'status-message status-success';
                successMsg.textContent = 'Comment saved successfully!';
                successMsg.style.marginBottom = '15px';
                document.querySelector('.comments-list').insertBefore(successMsg, document.querySelector('.comments-list').firstChild);
                
                setTimeout(() => {
                    if (successMsg.parentNode) {
                        successMsg.parentNode.removeChild(successMsg);
                    }
                }, 3000);

            } catch (error) {
                console.error('Error saving comment:', error);
                alert('Failed to save comment. Please try again.');
            } finally {
                // Re-enable save button
                saveCommentBtn.disabled = false;
                saveCommentBtn.style.opacity = '';
            }
        });

        // Allow saving with Ctrl+Enter
        commentTextarea.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                saveCommentBtn.click();
            }
        });
    }
</script>
</body>
</html>