<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=5.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#24143E">
    <meta name="format-detection" content="telephone=no">    <title>add media - the library sale</title>
    <!-- Google Fonts Import -->
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=B612+Mono&family=Dokdo&family=Kirang+Haerang&family=M+PLUS+2&family=Syne+Mono&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-auth-compat.js"></script>
    <!-- ZXing Barcode Scanner Library -->
    <script type="text/javascript" src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>
    <!-- App Utilities -->
    <script src="utils.js"></script>
    <script src="cache.js"></script>
    <script src="scanner-utils.js"></script>
    <!-- Styles -->
    <link rel="stylesheet" href="styles/variables.css">
    <link rel="stylesheet" href="styles/base.css">  
    <link rel="stylesheet" href="styles/components.css">
    <link rel="stylesheet" href="styles/pages.css">
    <!-- Main utilities -->
    <script src="main.js" defer></script>
</head>
<body>
    <header id="navbar-placeholder"></header>

    <main class="add-movie-container">
        <section class="hero-section">
            <h1 id="formTitle">add new media</h1>
        </section>
        <br>
        <!-- Search Section -->
        <section class="search-section">
            <div class="search-controls">
                <div  class="flex-center" style="flex-wrap: wrap; gap: var(--space-md);"> 
                <div class="search-bar">
                    <input type="text" id="movieSearch" placeholder="Type title, actor, director..."> 
                </div>              
                <button type="button" id="searchBtn" class="btn btn-rectangular btn-primary" title="search">
                    <span class="icon icon-search icon-lg"></span>
                </button>
                </div>
                <div class="loading-spinner" id="searchSpinner" style="display: none;"></div>
            </div>    
        </section>
                <br>
        <section class="button-section">
            <div>
                <button type="button" id="cameraBtn" class="btn btn-rectangular btn-primary">
                    scan barcode
                </button>
                <button type="button" id="manualBarcodeBtn" class="btn btn-rectangular btn-primary">
                    enter barcode
                </button>
            </div>
            <br>
            <div>
                <p class="text-muted">do u have too many?</p>
                <a href="bulk-scan.html" class="btn btn-rectangular btn-primary">
                    <span class="icon icon-bulk icon-md"></span>
                    take me to bulk scan
                </a>
            </div>
        </section>

        <!-- Scanner  -->
            <section id="scannerSection" class="scanner-section" style="display: none;">
                <div class="scanner-viewport">
                    <video id="video" autoplay muted playsinline></video>
                    <div class="scanner-guideline"></div> 
                    <div class="scanner-status" id="scannerStatus">position barcode in camera view</div>
                </div>
                <div class="quick-actions">
                    <p>position the barcode in the camera view girl cmon</p>
                    <button type="button" id="stop-scanner-btn" class="btn btn-lg btn-danger" title="stop scanner">
                        <i class="icon icon-close"></i>
                    </button>
                </div>
            </section>
            
            <div id="statusMessage"></div>
            <div id="searchResults"></div>
            
            <div id="searchFooter" class="search-footer" style="display: none;">
                <span id="resultCount"></span>
                <button id="loadMoreBtn" class="btn btn-rectangular btn-primary">load more</button>
            </div>
        </section>
        
        <hr class="list-divider">
        
        <!-- Media Details Form -->
        <section>
            <h2 class="heading-with-icon">
                <span class="icon icon-movie icon-sm"></span> <span class="icon icon-tv icon-sm"></span>
                media details
            </h2>
            <div id="form-skeleton" style="display: none;">
                <div class="details-main-content">
                    <div class="details-poster skeleton"></div>
                    <div class="details-info">
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 50px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 40px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 60px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 50px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <div class="skeleton" style="height: 16px; width: 40px; margin-bottom: 8px;"></div>
                    <div class="skeleton" style="height: 45px; width: 100%;"></div>
                </div>
                <div class="form-group">
                    <div class="skeleton" style="height: 16px; width: 70px; margin-bottom: 8px;"></div>
                    <div class="skeleton" style="height: 120px; width: 100%;"></div>
                </div>
            </div>
            <form id="movieForm">
                <div class="details-main-content">
                    <div class="details-poster">
                        <img id="movie-poster-img" src="https://placehold.co/300x450/2D194D/DEF0F7?text=poster.jpeg" alt="Movie Poster">
                    </div>
                    <div class="details-info">
                        <input type="hidden" id="editionDetailsInput">
                            <div class="form-group">
                                <label for="title">title *</label>
                                <input type="text" id="title" required readonly>
                            </div>
                            <div class="form-group">
                                <label for="year">year</label>
                                <input type="number" id="year" min="1900" max="2030" readonly>
                            </div>
                            <div class="form-group">
                                <label for="director">director</label>
                                <input type="text" id="director" readonly>
                            </div>
                            <div class="form-group">
                                <label for="genre">genre</label>
                                <input type="text" id="genre" readonly>
                            </div>
                            <div class="form-group">
                                <label for="cast">cast</label>
                                <input type="text" id="cast" placeholder="e.g., Leonardo DiCaprio, Joseph Gordon-Levitt" readonly>
                            </div>
                            <div class="form-group">
                                <label for="contentType">content type *</label>
                                <select id="contentType" required>
                                    <option value="movie">movie</option>
                                    <option value="tv">tv show</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="summary">summary</label>
                        <textarea id="summary" rows="6" placeholder="media summary from TMDd" readonly></textarea>
                    </div>
                    <!-- Physical Edition Details (shows when barcode data exists) -->
                    <div id="physicalEditionSection" class="form-group" style="display: none;">
                        <label>physical edition details</label>
                        <div class="physical-edition-info">
                            <div class="edition-row">
                                <span class="edition-label">format:</span>
                                <span id="editionFormat">-</span>
                            </div>
                            <div class="edition-row">
                                <span class="edition-label">edition:</span>
                                <span id="editionType">-</span>
                            </div>
                            <div class="edition-row">
                                <span class="edition-label">region:</span>
                                <span id="editionRegion">-</span>
                            </div>
                            <div class="edition-row">
                                <span class="edition-label">distributor:</span>
                                <span id="editionDistributor">-</span>
                            </div>
                            <div class="edition-row" id="editionFeaturesRow" style="display: none;">
                                <span class="edition-label">features:</span>
                                <span id="editionFeatures">-</span>
                            </div>
                            <div class="edition-row">
                                <span class="edition-label">barcode:</span>
                                <span id="editionBarcode">-</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- SUBMIT BUTTON -->
                <div class="flex-center" style="margin-top: var(--space-4xl);">
                    <button type="submit" id="save-btn" class="btn btn-xl btn-success" title="send it">
                            <i class="icon icon-confirm"></i>
                        </button>
                </div>
            </form>
        </section>
        
    </main>

    <!-- Alert Modal -->
    <div id="alertModal" class="modal">
        <div class="modal-content">
            <button class="btn btn-sm btn-secondary" id="alertModalClose" title="Close" style="position: absolute; top: var(--space-md); right: var(--space-md);">
                <span class="icon icon-close icon-sm"></span>
            </button>
            <h3 id="alertModalTitle">whomp whomp</h3>
            <p id="alertModalMessage">something happened :&#40</p>
            <div class="modal-buttons">
                <button class="btn btn-lg btn-primary" id="alertModalOk" title="OK">
                    <span class="icon icon-confirm icon-lg"></span>
                </button>
            </div>
        </div>
    </div>

    <script>
        let currentUser = null; 
        let isPublicFieldsEditable = true;
        let movieScanner = null;
        
        let currentSearchQuery = '';
        let currentPage = 1;
        let totalPages = 1;
        let totalResults = 0;
        let isLoadingMore = false;
        
        const apiCache = new CacheManager('tmdb_api_cache_', 50, 24);

        const TMDB_BASE_URL = '/api/tmdb';
        const UPC_BASE_URL = '/api/upc';
        const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';
    const firebaseConfig = {
      apiKey: "AIzaSyDDW8LtwpYevdkD7Q-_CxJ23mMfi00P21M",
      authDomain: "tiny-lizard.firebaseapp.com",
      projectId: "tiny-lizard",
      storageBucket: "tiny-lizard.firebasestorage.app",
      messagingSenderId: "250872474692",
      appId: "1:250872474692:web:969e0b1302ae3cb4666011",
    };
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore(); 
    const auth = firebase.auth(); 

    document.addEventListener('DOMContentLoaded', () => {
        auth.onAuthStateChanged(user => {
            if (user) {
                currentUser = user;
                initializePage();
            } else {
                window.location.href = 'auth.html'; 
            }
        });
    });

async function initializePage() {
        setupForm();
        setupSearch();
        await initializeMovieScanner();       
        
        // Create the modal on page load and define what happens on submit.
    ScannerUI.createManualEntryModal(async (barcode) => {
        // Use the manager's method to handle the barcode.
        // This will automatically call your onBarcodeScanned logic.
        await movieScanner.addManualBarcode(barcode); 
            return true; 
        }, () => {
            // Optional: Define a function for what happens on cancel.
            console.log('Manual entry cancelled.');
        });

        const urlParams = new URLSearchParams(window.location.search);
        const queryFromUrl = urlParams.get('query');
        const pageFromUrl = parseInt(urlParams.get('page')) || 1;
        if (queryFromUrl) {
            document.getElementById('movieSearch').value = queryFromUrl;
            performSearch(queryFromUrl, pageFromUrl);
        }
        
    document.getElementById('manualBarcodeBtn').addEventListener('click', () => {
    ScannerUI.showManualEntryModal();
    });
}


    function setupForm() {
        const form = document.getElementById('movieForm');
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            addMedia();
        });
    }
async function initializeMovieScanner() {
    // Define constants for the elements we'll be working with
    const cameraBtn = document.getElementById('cameraBtn');
    const stopBtn = document.getElementById('stop-scanner-btn');
    const scannerSection = document.getElementById('scannerSection');
    const videoEl = document.getElementById('video');

        movieScanner = new ScannerManager({
            continuous: false, // This is correct for single-item adding
            allowDuplicates: true,
            enableHapticFeedback: true,
            onBarcodeScanned: async (barcode) => {
                // When a barcode is found, hide the scanner view
                scannerSection.style.display = 'none';
                
                // Process the barcode as before
                try {
                    showStatusMessage('Looking up barcode...', 'info');
                    const lookupData = await MediaLookupUtils.completeMovieLookup(barcode);
                    const { tmdbData, upcData, physicalEdition } = lookupData; 
                    populateFormWithTMDBAndUPC(tmdbData, upcData, physicalEdition);
                    showStatusMessage('Movie details loaded successfully!', 'success');
                } catch (error) {
                    console.error('Movie lookup failed:', error);
                    showStatusMessage(`Lookup failed: ${error.message}. You can search manually or try again.`, 'error');
                }
            },
            onStatusUpdate: (message, type) => {
                // Correctly targets the status element inside the scanner section
                ScannerUI.updateStatus(message, type, 'scannerStatus');
            },
            onError: (message, context) => {
                console.error(`Scanner error (${context}):`, message);
                showStatusMessage(message, 'error');
                // Also hide the scanner if an error occurs
                scannerSection.style.display = 'none';
            }
        });
    
        // Initialize the scanner
        const initialized = await movieScanner.initialize();
        
        if (!initialized) {
            // Disable camera button if scanner fails to initialize
            if (cameraBtn) {
                cameraBtn.disabled = true;
                cameraBtn.innerHTML = '<span class="icon icon-close icon-md"></span>Scanner N/A';
            }
            return;
        }
    
        // CORRECTED: Event listener for the "Scan Barcode" button
        cameraBtn.addEventListener('click', async () => {
            if (movieScanner) {
                // Show the scanner section inline
                scannerSection.style.display = 'block'; 
                const success = await movieScanner.startCamera(videoEl, 'scannerStatus');
                
                if (!success) {
                    // Hide the section if the camera fails to start
                    scannerSection.style.display = 'none';
                }
            }
        });

        // CORRECTED: Event listener for the stop button
        stopBtn.addEventListener('click', () => {
            if (movieScanner) {
                movieScanner.stopCamera();
            }
            // Hide the scanner section
            scannerSection.style.display = 'none';
            document.getElementById('statusMessage').innerHTML = '';
        });
    }
    async function addMedia() {
        const submitBtn = document.getElementById('save-btn');
        if (submitBtn) {
            submitBtn.classList.add('saving');
        }

        try {
            const form = document.getElementById('movieForm');
            const titleValue = document.getElementById('title').value.trim();
            if (!titleValue) {
                throw new Error('Title is a required field. Please search for and select a movie first.');
            }
        
            const yearValue = document.getElementById('year').value;
            if (yearValue && (isNaN(yearValue) || yearValue < 1900 || yearValue > 2030)) {
                throw new Error('Please enter a valid year between 1900 and 2030.');
            }
        
            const tmdbId = document.getElementById('movieForm').dataset.tmdbId;
            let movieDocRef;

            if (tmdbId && tmdbId !== `upc_${document.getElementById('movieForm').dataset.upcCode}`) {
                const existingQuery = await db.collection('movies').where('tmdbId', '==', parseInt(tmdbId)).limit(1).get();
                if (!existingQuery.empty) {
                    movieDocRef = existingQuery.docs[0].ref;
                    console.log('Found existing movie in database');
                }
            }

            if (!movieDocRef) {
                const form = document.getElementById('movieForm');
                const mainMediaData = {
                    title: titleValue,
                    year: yearValue ? parseInt(yearValue) : null,
                    director: document.getElementById('director').value.trim(),
                    genre: document.getElementById('genre').value.trim(),
                    posterUrl: form.dataset.posterUrl || null,
                    runtime: form.dataset.runtime ? parseInt(form.dataset.runtime) : null,
                    tmdbId: tmdbId && !tmdbId.startsWith('upc_') ? parseInt(tmdbId) : null,
                    overview: document.getElementById('summary').value.trim(),
                    cast: document.getElementById('cast').value.split(',').map(c => c.trim()).filter(c => c),
                    contentType: document.getElementById('contentType').value,
                    dateAdded: firebase.firestore.FieldValue.serverTimestamp(),
                    originalUploaderId: currentUser.uid,
                    originalUploaderDisplayName: currentUser.displayName || currentUser.email,
                    isManualEntry: isPublicFieldsEditable,
                };
                
                console.log('Creating new movie entry:', mainMediaData);
                movieDocRef = await db.collection('movies').add(mainMediaData);
            }

            const userInteractionData = {
                movieId: movieDocRef.id,
                rating: 0,
                review: "",
                watched: false,
                watchedDate: null,
                owned: true,
                interactionDate: firebase.firestore.FieldValue.serverTimestamp(),
                upc: form.dataset.upcCode || '',
                physicalEdition: JSON.parse(form.dataset.physicalEdition || '{}')
            };

            await db.collection('users').doc(currentUser.uid).collection('movieInteractions').doc(movieDocRef.id).set(userInteractionData);
        
            showTimedRedirectModal('Success!', 'Media added to your library! You will now be taken to edit your personal details.', `edit-movie.html?id=${movieDocRef.id}`, 3);

        } catch (error) {
            console.error('Error adding media:', error);
            
            const errorMessage = document.createElement('div');
            errorMessage.className = 'status-message status-error';
            errorMessage.innerHTML = `<span class="icon icon-close icon-md"></span>${error.message}`;
            errorMessage.style.position = 'fixed';
            errorMessage.style.top = 'var(--space-xl)';
            errorMessage.style.right = 'var(--space-xl)';
            errorMessage.style.zIndex = 'var(--z-modal)';
            document.body.appendChild(errorMessage);
            
            setTimeout(() => errorMessage.remove(), 5000);
        } finally {
            if (submitBtn) {
                submitBtn.classList.remove('saving');
            }
        }
    }

    function populateFormWithData(data) {
        document.getElementById('title').value = data.title || data.name;
        document.getElementById('year').value = (data.release_date || data.first_air_date || '').substring(0, 4);
        document.getElementById('summary').value = data.overview;
        document.getElementById('genre').value = data.genres.map(g => g.name).join(', ');
        document.getElementById('cast').value = data.credits.cast.slice(0, 5).map(c => c.name).join(', ');
        const director = data.credits.crew.find(c => c.job === 'Director');
        document.getElementById('director').value = director ? director.name : '';
        document.getElementById('contentType').value = data.media_type || (data.seasons ? 'tv' : 'movie');
        
        const posterUrl = data.poster_path ? TMDB_IMAGE_BASE + data.poster_path : 'https://placehold.co/300x450/2D194D/DEF0F7?text=No+Poster';
        document.getElementById('movie-poster-img').src = posterUrl;
        
        document.getElementById('movieForm').dataset.tmdbId = data.id;
        document.getElementById('movieForm').dataset.posterUrl = posterUrl;
        document.getElementById('movieForm').dataset.runtime = data.runtime || (data.episode_run_time ? data.episode_run_time[0] : null);

        togglePublicFieldsReadonly(true);
        isPublicFieldsEditable = false;
    }
    function togglePublicFieldsReadonly(isReadonly) {
        const fields = ['title', 'year', 'director', 'genre', 'summary', 'cast', 'contentType'];
        fields.forEach(id => {
            const el = document.getElementById(id);
            if (el.tagName === 'SELECT') el.disabled = isReadonly;
            else el.readOnly = isReadonly;
        });
    }
    function showStatusMessage(message, type) {
        const statusDiv = document.getElementById('statusMessage');
        const iconClass = type === 'success' ? 'icon-confirm' : type === 'error' ? 'icon-close' : 'icon-details';
        
        statusDiv.innerHTML = `
            <div class="status-message status-${type}" style="
                position: fixed;
                top: var(--space-lg);
                left: var(--space-md);
                right: var(--space-md);
                z-index: var(--z-modal);
                text-align: center;
                font-size: var(--font-size-base);
                padding: var(--space-lg);
                border-radius: var(--radius-lg);
                box-shadow: var(--shadow-lg);
            ">
                <span class="icon ${iconClass} icon-md"></span>
                ${message}
            </div>
        `;
        
        if (window.innerWidth <= 768) {
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 4000);
        }
    }
    function showTimedRedirectModal(title, message, redirectUrl, duration = 5) {
    const modal = document.getElementById('alertModal');
    if (!modal) {
        alert(message);
        setTimeout(() => { window.location.href = redirectUrl; }, 100);
        return;
    }

    const titleEl = modal.querySelector('#alertModalTitle');
    const messageEl = modal.querySelector('#alertModalMessage');
    const okBtn = modal.querySelector('#alertModalOk');
    const closeBtn = modal.querySelector('#alertModalClose');

    titleEl.textContent = title;
    okBtn.style.display = 'inline-flex';
    closeBtn.style.display = 'flex';

    let countdown = duration;
    const isMobile = window.innerWidth <= 768;
    
    messageEl.innerHTML = isMobile 
        ? `${message}<br><br><strong>Redirecting in ${countdown}s...</strong>`
        : `${message}<br><br>Redirecting in ${countdown} seconds...`;
    
    modal.classList.add('active');

    const interval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            messageEl.innerHTML = isMobile 
                ? `${message}<br><br><strong>Redirecting in ${countdown}s...</strong>`
                : `${message}<br><br>Redirecting in ${countdown} seconds...`;
        } else {
            clearInterval(interval);
            window.location.href = redirectUrl;
        }
    }, 1000);

    const cleanup = () => {
        clearInterval(interval);
        modal.classList.remove('active');
    };
    
    okBtn.onclick = () => {
        cleanup();
        window.location.href = redirectUrl;
    };

    closeBtn.onclick = cleanup;
    
    modal.onclick = (e) => {
        if (e.target === modal) {
            cleanup();
        }
    };
}

    function setupSearch() {
        const searchInput = document.getElementById('movieSearch');
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        
        // Use simple validation instead of LibraryUtils
        const debouncedSearch = createSimpleDebounce((query) => {
            const sanitizedQuery = query.trim();
            if (sanitizedQuery.length > 2) {
                performSearch(sanitizedQuery, 1);
            } else {
                document.getElementById('searchResults').innerHTML = '';
                document.getElementById('searchFooter').style.display = 'none';
            }
        }, 500);
        
        searchInput.addEventListener('input', (e) => {
            debouncedSearch(e.target.value);
        });
        
        document.getElementById('searchBtn').addEventListener('click', () => {
            const sanitizedQuery = searchInput.value.trim();
            performSearch(sanitizedQuery, 1);
        });
        
        loadMoreBtn.addEventListener('click', () => {
            if (isLoadingMore || currentPage >= totalPages) return;
            performSearch(currentSearchQuery, currentPage + 1);
        });
    }

    // Simple debounce function to replace LibraryUtils dependency
    function createSimpleDebounce(func, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }

    async function performSearch(query, page = 1) {
        if (!query || isLoadingMore) return;
        
        const isNewSearch = page === 1;
        if (isNewSearch) {
            currentSearchQuery = query;
            currentPage = 1;
        }
        
        isLoadingMore = true;
        
        const cacheKey = `search_${query.toLowerCase().replace(/\s+/g, '_')}_p${page}`;
        const cachedData = apiCache.get('multi-search', cacheKey);
        
        if (cachedData) {
            processAndDisplayResults(cachedData, query, isNewSearch);
            isLoadingMore = false;
            return;
        }
        
        if (isNewSearch) {
            document.getElementById('searchResults').innerHTML = `<div class="loading-container"><div class="loading-spinner" style="display: block;"></div></div>`;
        } else {
            document.getElementById('loadMoreBtn').textContent = 'Loading...';
            document.getElementById('loadMoreBtn').disabled = true;
        }
        
        try {
            const searchUrl = `${TMDB_BASE_URL}/search/multi?query=${encodeURIComponent(query)}&page=${page}`;
            const response = await fetch(searchUrl);
            const data = await response.json();
            
            apiCache.set('multi-search', cacheKey, data);
            processAndDisplayResults(data, query, isNewSearch);
            
        } catch (error) {
            console.error('Search error:', error);
            showStatusMessage('Search failed.', 'error');
        } finally {
            isLoadingMore = false;
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            loadMoreBtn.textContent = 'Load More';
            loadMoreBtn.disabled = currentPage >= totalPages;
        }
    }
    async function searchTMDBAndPopulate(title, year, upcData) {
        try {
            // Build search query - include year if we have it for better accuracy
            let searchQuery = title;
            if (year) {
                searchQuery += ` ${year}`;
            }
            
            console.log('Searching TMDB for:', searchQuery);
            
            // Search TMDB
            const searchUrl = `${TMDB_BASE_URL}/search/multi?query=${encodeURIComponent(searchQuery)}`;
            const response = await fetch(searchUrl);
            const searchData = await response.json();
            
            if (!response.ok || !searchData.results || searchData.results.length === 0) {
                // If search with year fails, try without year
                if (year) {
                    console.log('Search with year failed, trying without year...');
                    return await searchTMDBAndPopulate(title, null, upcData);
                }
                throw new Error(`No TMDB results found for "${title}"`);
            }
            
            // Filter to movies/TV shows only
            const mediaResults = searchData.results.filter(item => 
                item.media_type === 'movie' || item.media_type === 'tv'
            );
            
            if (mediaResults.length === 0) {
                throw new Error(`No movies or TV shows found for "${title}"`);
            }
            
            // Find best match - prioritize exact title matches and year matches
            let bestMatch = mediaResults[0];
            
            for (const result of mediaResults) {
                const resultTitle = (result.title || result.name || '').toLowerCase();
                const resultYear = parseInt((result.release_date || result.first_air_date || '').substring(0, 4));
                
                // Prefer exact title match
                if (resultTitle === title.toLowerCase()) {
                    bestMatch = result;
                    // If year also matches, this is definitely the best
                    if (year && resultYear === parseInt(year.substring(0, 4))) {
                        break;
                    }
                }
                // If no exact title match yet, prefer year match
                else if (year && resultYear === parseInt(year.substring(0, 4)) && 
                        resultTitle.includes(title.toLowerCase().split(' ')[0])) {
                    bestMatch = result;
                }
            }
            
            console.log('Best TMDB match:', bestMatch);
            showStatusMessage('Found TMDB match! Loading full details...', 'info');
            
            // Step 3: Get full details for the best match
            const detailsUrl = `${TMDB_BASE_URL}/${bestMatch.media_type}/${bestMatch.id}?append_to_response=credits`;
            const detailsResponse = await fetch(detailsUrl);
            const detailsData = await detailsResponse.json();
            
            if (!detailsResponse.ok) {
                throw new Error('Failed to load full movie details from TMDB');
            }
            
            // Step 4: Combine TMDB data with UPC data and populate form
            populateFormWithTMDBAndUPC(detailsData, upcData);
            
            showStatusMessage('Movie details loaded successfully from TMDB!', 'success');
            
        } catch (error) {
            console.error('TMDB search failed:', error);
            
            // Fallback: Create basic entry with UPC data only
            showStatusMessage(`TMDB search failed: ${error.message}. Using basic UPC data.`, 'error');
            
            setTimeout(() => {
                if (confirm('Could not find this movie in TMDB. Would you like to create a basic entry with the UPC data, or search manually?')) {
                    createBasicUPCEntry(title, upcData);
                } else {
                    document.getElementById('movieSearch').value = title;
                    performSearch(title, 1);
                }
            }, 2000);
        }
    }
    function populateFormWithTMDBAndUPC(tmdbData, upcData, physicalEdition) {
        // Use TMDB data for all the rich movie info
        document.getElementById('title').value = tmdbData.title || tmdbData.name;
        document.getElementById('year').value = (tmdbData.release_date || tmdbData.first_air_date || '').substring(0, 4);
        document.getElementById('summary').value = tmdbData.overview || 'No summary available';
        document.getElementById('genre').value = tmdbData.genres ? tmdbData.genres.map(g => g.name).join(', ') : '';
        document.getElementById('cast').value = tmdbData.credits && tmdbData.credits.cast ? 
            tmdbData.credits.cast.slice(0, 5).map(c => c.name).join(', ') : '';
        
        const director = tmdbData.credits && tmdbData.credits.crew ? 
            tmdbData.credits.crew.find(c => c.job === 'Director') : null;
        document.getElementById('director').value = director ? director.name : '';
        
        document.getElementById('contentType').value = tmdbData.media_type || (tmdbData.seasons ? 'tv' : 'movie');
        
        // Use TMDB poster
        const posterUrl = tmdbData.poster_path ? 
            TMDB_IMAGE_BASE + tmdbData.poster_path : 
            'https://placehold.co/300x450/2D194D/DEF0F7?text=No+Poster';
        document.getElementById('movie-poster-img').src = posterUrl;
        
        // Store both TMDB and UPC data in the form
        const form = document.getElementById('movieForm');
        form.dataset.tmdbId = tmdbData.id;
        form.dataset.posterUrl = posterUrl;
        form.dataset.runtime = tmdbData.runtime || (tmdbData.episode_run_time ? tmdbData.episode_run_time[0] : null);

        // Store UPC/barcode data
        form.dataset.upcCode = upcData.barcode;
        form.dataset.upcBrand = upcData.brand;
        form.dataset.upcCategory = upcData.category;
        form.dataset.upcOriginalTitle = upcData.originalTitle;
        form.dataset.upcDescription = upcData.description;
        
        // FIX: If physicalEdition wasn't passed, create it from upcData
        if (!physicalEdition && upcData && window.MediaLookupUtils) {
            physicalEdition = MediaLookupUtils.createPhysicalEditionData(upcData);
        }

        form.dataset.physicalEdition = JSON.stringify(physicalEdition || {});

        // Make fields readonly since we have good data
        togglePublicFieldsReadonly(true);
        isPublicFieldsEditable = false;
        
        console.log('Form populated with TMDB + UPC data:', {
            tmdb: tmdbData.title || tmdbData.name,
            upc: upcData.originalTitle,
            barcode: upcData.barcode
        });

        // FIX: Pass the correct physicalEdition object
        displayPhysicalEditionDetails(physicalEdition, upcData.barcode);
    }
    function displayPhysicalEditionDetails(physicalEdition, barcode) {
        const section = document.getElementById('physicalEditionSection');
        if (!physicalEdition || !barcode) {
            section.style.display = 'none';
            return;
        }
        
        section.style.display = 'block';
        document.getElementById('editionFormat').textContent = physicalEdition.format || 'Unknown';
        document.getElementById('editionType').textContent = physicalEdition.edition || 'Standard';
        document.getElementById('editionRegion').textContent = physicalEdition.region || 'Unknown';
        document.getElementById('editionDistributor').textContent = physicalEdition.distributor || 'Unknown';
        document.getElementById('editionBarcode').textContent = barcode;
        
        const featuresRow = document.getElementById('editionFeaturesRow');
        const featuresSpan = document.getElementById('editionFeatures');
        
        if (physicalEdition.features && physicalEdition.features.length > 0) {
            featuresRow.style.display = 'flex';
            featuresSpan.textContent = physicalEdition.features.join(', ');
        } else {
            featuresRow.style.display = 'none';
        }
    }
    function createBasicUPCEntry(cleanTitle, upcData) {
        const mockTmdbData = {
            id: `upc_${upcData.barcode}`,
            title: cleanTitle,
            name: cleanTitle,
            overview: upcData.description || 'No description available',
            release_date: '',
            first_air_date: '',
            poster_path: null,
            genres: upcData.category ? [{ name: upcData.category }] : [],
            credits: {
                cast: [],
                crew: upcData.brand ? [{ job: 'Studio', name: upcData.brand }] : []
            },
            media_type: 'movie'
        };
        
        populateFormWithTMDBAndUPC(mockTmdbData, upcData);
        showStatusMessage('Basic entry created with UPC data. You can edit details before saving.', 'info');
    }
    function processAndDisplayResults(data, query, isNewSearch) {
            currentPage = data.page;
            totalPages = data.total_pages;
            totalResults = data.total_results;
            
            const results = data.results.filter(item => item.media_type === 'movie' || item.media_type === 'tv')
                .map(item => ({ ...item, score: calculateRelevanceScore(item, query) }))
                .sort((a, b) => b.score - a.score);
            
            displayResults(results, isNewSearch);
            updateUrl(query, currentPage);
            updateSearchFooter();
        }
    function calculateRelevanceScore(item, query) {
            const keywords = query.toLowerCase().split(' ').filter(k => k.length > 2);
            const title = (item.title || item.name || '').toLowerCase();
            const overview = (item.overview || '').toLowerCase();
            let score = 0;
            
            keywords.forEach(keyword => {
                if (title === keyword) score += 100;
                if (title.startsWith(keyword)) score += 50;
                if (title.includes(keyword)) score += 20;
                if (overview.includes(keyword)) score += 5;
            });
            
            const releaseYear = parseInt((item.release_date || item.first_air_date || '').substring(0, 4));
            if (releaseYear > 2020) score += 5;
            score += Math.min(item.popularity / 10, 20);
            score += (item.vote_average || 0) * 2;
            
            return score;
        }
    function displayResults(results, isNewSearch) {
        const resultsDiv = document.getElementById('searchResults');
        if (isNewSearch) {
            resultsDiv.innerHTML = '';
        }
        
        if (results.length === 0 && isNewSearch) {
            resultsDiv.innerHTML = `<div class="empty-state"><span class="icon icon-search icon-3xl"></span><h3>No results found</h3><p>Try adjusting your search terms.</p></div>`;
            return;
        }
        
        const resultsHTML = results.map((item) => {
            const title = item.title || item.name;
            const year = (item.release_date || item.first_air_date || '').substring(0, 4);
            // Simple text truncation instead of LibraryUtils
            const overview = truncateText(item.overview, 100);
            const badgeHTML = item.media_type === 'tv' 
                ? `<span class="badge badge-tv" title="TV Show"><span class="icon icon-tv icon-sm"></span></span>`
                : `<span class="badge badge-movie" title="Movie"><span class="icon icon-movie icon-sm"></span></span>`;
            
            return `
                <div class="search-result" onclick="selectMedia('${item.id}', '${item.media_type}')">
                    <img src="${item.poster_path ? TMDB_IMAGE_BASE + item.poster_path : 'https://placehold.co/50x75/2D194D/DEF0F7?text=N/A'}" 
                        class="search-result-poster" 
                        loading="lazy"
                        onerror="this.style.display='none'">
                    <div class="search-result-info">
                        <h4>${title} (${year}) ${badgeHTML}</h4>
                        <p>${overview}</p>
                    </div>
                </div>
            `;
        }).join('');
        
        resultsDiv.insertAdjacentHTML('beforeend', resultsHTML);
    }
    function updateSearchFooter() {
            const footer = document.getElementById('searchFooter');
            const countSpan = document.getElementById('resultCount');
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            
            if (totalResults > 0) {
                footer.style.display = 'flex';
                const itemsShown = document.getElementById('searchResults').children.length;
                countSpan.textContent = `Showing ${itemsShown} of ${totalResults} results`;
                
                if (currentPage < totalPages) {
                    loadMoreBtn.style.display = 'block';
                    loadMoreBtn.disabled = false;
                } else {
                    loadMoreBtn.style.display = 'none';
                }
            } else {
                footer.style.display = 'none';
            }
        }
    function updateUrl(query, page) {
            const url = new URL(window.location);
            url.searchParams.set('query', query);
            url.searchParams.set('page', page);
            window.history.pushState({ path: url.href }, '', url.href);
        }
    function truncateText(text, maxLength) {
        if (!text) return '';
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength - 3) + '...';
    }
async function selectMedia(id, type) {
        const selectedResult = event.target.closest('.search-result');
        if (selectedResult) {
            selectedResult.classList.add('selected');
            const allResults = document.querySelectorAll('.search-result');
            allResults.forEach(result => {
                if (result !== selectedResult) {
                    result.style.opacity = '0.5';
                    result.style.pointerEvents = 'none';
                }
            });
        }

        showMovieSelectionSkeleton();
        
        const cacheKey = `details_${type}_${id}`;
        const cachedData = apiCache.get('details', cacheKey);
        
        if (cachedData) {
            setTimeout(() => {
                hideMovieSelectionSkeleton();
                populateFormWithData(cachedData);
                clearSearchResults();
                showStatusMessage('Movie details loaded successfully!', 'success');
                setTimeout(() => {
                    document.getElementById('statusMessage').innerHTML = '';
                }, 3000);
            }, 300);
            return;
        }

        try {
            const response = await fetch(`${TMDB_BASE_URL}/${type}/${id}?append_to_response=credits`);
            const data = await response.json();
            
            if (!response.ok) {
                throw new Error('Failed to load movie details');
            }
            
            apiCache.set('details', cacheKey, data);
            hideMovieSelectionSkeleton();
            populateFormWithData(data);
            clearSearchResults();
            
            showStatusMessage('Movie details loaded successfully!', 'success');
            setTimeout(() => {
                document.getElementById('statusMessage').innerHTML = '';
            }, 3000);
            
        } catch (error) {
            hideMovieSelectionSkeleton();
            if (selectedResult) {
                selectedResult.classList.remove('selected');
                const allResults = document.querySelectorAll('.search-result');
                allResults.forEach(result => {
                    result.style.opacity = '';
                    result.style.pointerEvents = '';
                });
            }
            
            // Simple error handling instead of LibraryUtils
            console.error('Loading media details error:', error);
            showStatusMessage('Failed to load movie details. Please try again.', 'error');
        }
    }
    function clearSearchResults() {
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('searchFooter').style.display = 'none';
            document.getElementById('movieSearch').value = '';
            
            currentSearchQuery = '';
            currentPage = 1;
            totalPages = 1;
            totalResults = 0;
            isLoadingMore = false;
        }
    function showMovieSelectionSkeleton() {
            // Hide the real form and show the skeleton UI
            document.getElementById('movieForm').style.display = 'none';
            document.getElementById('form-skeleton').style.display = 'block';
        }
    function hideMovieSelectionSkeleton() {
            // Hide the skeleton UI and show the real form
            document.getElementById('form-skeleton').style.display = 'none';
            document.getElementById('movieForm').style.display = 'block';
        }

    function validateFormOnMobile() {
        const titleValue = document.getElementById('title').value.trim();
        if (!titleValue) {
            showStatusMessage('Please search for and select a movie first.', 'error');
            
            // Scroll to search section on mobile
            if (window.innerWidth <= 768) {
                document.querySelector('.search-section').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }
            return false;
        }
        return true;
    }

// === TEST FUNCTION FOR DEBUGGING UPC API ===
window.testUPCLookup = async function(testBarcode = '883929736171') {
    console.log('🔍 Testing UPC lookup with barcode:', testBarcode);
    
    try {
        const response = await fetch(`/api/upc?upc=${testBarcode}`);
        console.log('Response status:', response.status);
        console.log('Response ok:', response.ok);
        
        if (response.ok) {
            const data = await response.json();
            console.log('✅ UPC API Response:', data);
            
            if (data.code === 'OK' && data.items && data.items.length > 0) {
                console.log('📦 First item:', data.items[0]);
                console.log('🎬 Title:', data.items[0].title);
                console.log('📝 Description:', data.items[0].description);
                console.log('🏷️ Category:', data.items[0].category);
                console.log('🏢 Brand:', data.items[0].brand);
            } else {
                console.log('❌ No items found or API returned error');
            }
        } else {
            const errorData = await response.json().catch(() => ({}));
            console.log('❌ API Error:', errorData);
        }
    } catch (error) {
        console.error('💥 Request failed:', error);
    }
};

(function initializeMobileImprovements() {
    // Only run once when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupMobileImprovements);
    } else {
        setupMobileImprovements();
    }
    
    function setupMobileImprovements() {
        // Improve touch targets on mobile
        if (window.innerWidth <= 768) {
            const style = document.createElement('style');
            style.textContent = `
                .search-result {
                    min-height: 60px;
                    touch-action: manipulation;
                }
                .btn {
                    touch-action: manipulation;
                }
                .star-rating-interactive .star {
                    touch-action: manipulation;
                    padding: var(--space-xs);
                }
            `;
            document.head.appendChild(style);
        }
        
        // Prevent zoom on input focus for iOS
        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
            const inputs = document.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
                if (parseFloat(getComputedStyle(input).fontSize) < 16) {
                    input.style.fontSize = '16px';
                }
            });
        }
    }
})();
    </script>
    <footer id="footer-placeholder"></footer>
</body>
</html>
