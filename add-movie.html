<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=5.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#24143E">
    <meta name="format-detection" content="telephone=no">    <title>Add Media - the library sale</title>
    <!-- Google Fonts Import -->
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=B612+Mono&family=Dokdo&family=Kirang+Haerang&family=M+PLUS+2&family=Syne+Mono&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-auth-compat.js"></script>
    <!-- ZXing Barcode Scanner Library -->
    <script type="text/javascript" src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>
    <!-- App Utilities -->
    <script src="utils.js"></script>
    <script src="cache.js"></script>
    <link rel="stylesheet" href="styles/variables.css">
    <link rel="stylesheet" href="styles/base.css">  
    <link rel="stylesheet" href="styles/components.css">
    <link rel="stylesheet" href="styles/pages.css">
    <script src="main.js" defer></script>
</head>
<body>
    <header id="navbar-placeholder"></header>

    <main class="add-movie-container">
        <section class="hero-section">
            <h1 id="formTitle">Add New Media</h1>
        </section>
        <br>
        <!-- Search Section -->
        <section class="search-section">
            <div class="search-controls">
                <div  class="flex-center" style="flex-wrap: wrap; gap: var(--space-md);"> 
                <div class="search-bar">
                    <input type="text" id="movieSearch" placeholder="Type title, actor, director..."> 
                </div>              
                <button type="button" id="searchBtn" class="btn btn-rectangular btn-primary" title="Search">
                    <span class="icon icon-search icon-md"></span>
                </button>
                </div>
                <div class="loading-spinner" id="searchSpinner" style="display: none;"></div>
                <br>
                <button type="button" id="cameraBtn" class="btn btn-rectangular btn-primary">
                    Scan Barcode
                </button>
                <button type="button" id="manualBarcodeBtn" class="btn btn-rectangular btn-primary">
                    Enter Barcode
                </button>
            </div>
            
            <div id="manualBarcodeInput" class="form-group" style="display: none;">
                <label for="barcodeInput">Barcode (8-18 digits)</label>
                <div class="flex gap-md">
                    <input type="text" id="barcodeInput" placeholder="Enter 8-18 digit barcode" pattern="[0-9]{8,18}" maxlength="18" style="flex: 1;">
                    <button type="button" id="lookupBarcodeBtn" class="btn btn-md btn-primary">
                        <span class="icon icon-search icon-md"></span>
                        Lookup
                    </button>
                    <button type="button" id="cancelBarcodeBtn" class="btn btn-md btn-secondary">
                        <span class="icon icon-close icon-3xl"></span>
                        Cancel
                    </button>
                </div>
                <small class="text-muted">UPC/EAN barcodes are typically 12-13 digits</small>
                <div class="loading-spinner" id="barcodeSpinner" style="display: none;"></div>
            </div>
            
            <!-- Scanner Modal -->
            <div id="scannerContainer" class="modal">
                <div class="modal-content">
                    <h3>Scan Barcode</h3>
                    <div class="scanner-viewport">
                        <video id="video" autoplay muted playsinline style="width: 100%; max-width: 400px; height: 300px; border-radius: var(--radius-lg); background: var(--color-secondary-bg);"></video>
                    </div>
                    <p>Position barcode in camera view</p>
                    <div class="modal-buttons">
                        <button type="button" id="stop-scanner-btn" class="btn btn-lg btn-danger">
                            <i class="icon icon-close"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="statusMessage"></div>
            <div id="searchResults"></div>
            
            <div id="searchFooter" class="search-footer" style="display: none;">
                <span id="resultCount"></span>
                <button id="loadMoreBtn" class="btn btn-rectangular btn-primary">Load More</button>
            </div>
        </section>
        
        <hr class="list-divider">
        
        <!-- Media Details Form -->
        <section>
            <h2 class="heading-with-icon">
                <span class="icon icon-movie icon-sm"></span> <span class="icon icon-tv icon-sm"></span>
                Media Details
            </h2>
            <div id="form-skeleton" style="display: none;">
                <div class="details-main-content">
                    <div class="details-poster skeleton"></div>
                    <div class="details-info">
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 50px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 40px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 60px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                        <div class="form-group">
                            <div class="skeleton" style="height: 16px; width: 50px; margin-bottom: 8px;"></div>
                            <div class="skeleton" style="height: 45px; width: 100%;"></div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <div class="skeleton" style="height: 16px; width: 40px; margin-bottom: 8px;"></div>
                    <div class="skeleton" style="height: 45px; width: 100%;"></div>
                </div>
                <div class="form-group">
                    <div class="skeleton" style="height: 16px; width: 70px; margin-bottom: 8px;"></div>
                    <div class="skeleton" style="height: 120px; width: 100%;"></div>
                </div>
            </div>
            <form id="movieForm">
                <div class="details-main-content">
                    <div class="details-poster">
                        <img id="movie-poster-img" src="https://placehold.co/300x450/2D194D/DEF0F7?text=Poster" alt="Movie Poster">
                    </div>
                    <div class="details-info">
                        <input type="hidden" id="editionDetailsInput">
                            <div class="form-group">
                                <label for="title">Title *</label>
                                <input type="text" id="title" required readonly>
                            </div>
                            <div class="form-group">
                                <label for="year">Year</label>
                                <input type="number" id="year" min="1900" max="2030" readonly>
                            </div>
                            <div class="form-group">
                                <label for="director">Director</label>
                                <input type="text" id="director" readonly>
                            </div>
                            <div class="form-group">
                                <label for="genre">Genre</label>
                                <input type="text" id="genre" readonly>
                            </div>
                            <div class="form-group">
                                <label for="cast">Cast</label>
                                <input type="text" id="cast" placeholder="e.g., Leonardo DiCaprio, Joseph Gordon-Levitt" readonly>
                            </div>
                            <div class="form-group">
                                <label for="contentType">Content Type *</label>
                                <select id="contentType" required>
                                    <option value="movie">Movie</option>
                                    <option value="tv">TV Show</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="summary">Summary</label>
                        <textarea id="summary" rows="6" placeholder="Media summary from TMDb" readonly></textarea>
                    </div>
                </div>

                <!-- SUBMIT BUTTON -->
                <div class="flex-center" style="margin-top: var(--space-4xl);">
                    <button type="submit" id="save-btn" class="btn btn-xl btn-success" title="Add Media">
                            <i class="icon icon-confirm"></i>
                        </button>
                </div>
            </form>
        </section>
        
    </main>

    <!-- Alert Modal -->
    <div id="alertModal" class="modal">
        <div class="modal-content">
            <button class="btn btn-sm btn-secondary" id="alertModalClose" title="Close" style="position: absolute; top: var(--space-md); right: var(--space-md);">
                <span class="icon icon-close icon-sm"></span>
            </button>
            <h3 id="alertModalTitle">Alert</h3>
            <p id="alertModalMessage">Something happened.</p>
            <div class="modal-buttons">
                <button class="btn btn-lg btn-primary" id="alertModalOk" title="OK">
                    <span class="icon icon-confirm icon-lg"></span>
                </button>
            </div>
        </div>
    </div>

    <script>
        let currentUser = null; 
        let isPublicFieldsEditable = true;
        let codeReader = null;
        let videoInputDevices = [];
        
        let currentSearchQuery = '';
        let currentPage = 1;
        let totalPages = 1;
        let totalResults = 0;
        let isLoadingMore = false;
        
        const apiCache = new CacheManager('tmdb_api_cache_', 50, 24);

        const TMDB_BASE_URL = '/api/tmdb';
        const UPC_BASE_URL = '/api/upc';
        const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';

        const firebaseConfig = {
          apiKey: "AIzaSyDDW8LtwpYevdkD7Q-_CxJ23mMfi00P21M",
          authDomain: "tiny-lizard.firebaseapp.com",
          projectId: "tiny-lizard",
          storageBucket: "tiny-lizard.firebasestorage.app",
          messagingSenderId: "250872474692",
          appId: "1:250872474692:web:969e0b1302ae3cb4666011",
        };
        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore(); 
        const auth = firebase.auth(); 

        document.addEventListener('DOMContentLoaded', () => {
            auth.onAuthStateChanged(user => {
                if (user) {
                    currentUser = user;
                    initializePage();
                } else {
                    window.location.href = 'auth.html'; 
                }
            });
        });

        function initializePage() {
            setupForm();
            setupSearch();
            setupBarcodeScanner();
            
            const urlParams = new URLSearchParams(window.location.search);
            const queryFromUrl = urlParams.get('query');
            const pageFromUrl = parseInt(urlParams.get('page')) || 1;
            if (queryFromUrl) {
                document.getElementById('movieSearch').value = queryFromUrl;
                performSearch(queryFromUrl, pageFromUrl);
            }
        }

        function setupForm() {
            const form = document.getElementById('movieForm');
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                addMedia();
            });
        }
        
        async function addMedia() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.classList.add('saving');

            try {
                const titleValue = LibraryUtils.validation.sanitizeInput(document.getElementById('title').value);
                if (!titleValue) throw new Error('Title is a required field. Please search for and select a movie first.');
            
                const yearValue = document.getElementById('year').value;
                if (yearValue && !LibraryUtils.validation.isValidYear(yearValue)) throw new Error('Please enter a valid year.');
            
                const tmdbId = document.getElementById('movieForm').dataset.tmdbId;
                let movieDocRef;

                if (tmdbId) {
                    const existingQuery = await db.collection('movies').where('tmdbId', '==', parseInt(tmdbId)).limit(1).get();
                    if (!existingQuery.empty) {
                        movieDocRef = existingQuery.docs[0].ref;
                    }
                }
        
                if (!movieDocRef) {
                    const mainMediaData = {
                        title: titleValue, 
                        year: yearValue ? parseInt(yearValue) : null, 
                        director: LibraryUtils.validation.sanitizeInput(document.getElementById('director').value),
                        genre: LibraryUtils.validation.sanitizeInput(document.getElementById('genre').value), 
                        posterUrl: document.getElementById('movieForm').dataset.posterUrl || null,
                        runtime: document.getElementById('movieForm').dataset.runtime || null, 
                        tmdbId: tmdbId ? parseInt(tmdbId) : null,
                        overview: LibraryUtils.validation.sanitizeInput(document.getElementById('summary').value, 1000), 
                        cast: document.getElementById('cast').value.split(',').map(c => LibraryUtils.validation.sanitizeInput(c)),
                        contentType: document.getElementById('contentType').value, 
                        dateAdded: firebase.firestore.FieldValue.serverTimestamp(),
                        originalUploaderId: currentUser.uid, 
                        originalUploaderDisplayName: currentUser.displayName || currentUser.email, 
                        isManualEntry: isPublicFieldsEditable
                    };
                    movieDocRef = await db.collection('movies').add(mainMediaData);
                }

                // Create a default user interaction object
                const userInteractionData = {
                    movieId: movieDocRef.id,
                    rating: 0, 
                    review: "",
                    watched: false,
                    watchedDate: null,
                    owned: false,
                    interactionDate: firebase.firestore.FieldValue.serverTimestamp()
                };

                await db.collection('users').doc(currentUser.uid).collection('movieInteractions').doc(movieDocRef.id).set(userInteractionData);
            
                showTimedRedirectModal('Success!', 'Media added to the library. You will now be taken to edit your details.', `edit-movie.html?id=${movieDocRef.id}`, 3);

            } catch (error) {
                LibraryUtils.errors.handleError(error, 'Adding Media');
                
                const errorMessage = document.createElement('div');
                errorMessage.className = 'status-message status-error';
                errorMessage.innerHTML = `<span class="icon icon-close icon-md"></span>${error.message}`;
                errorMessage.style.position = 'fixed';
                errorMessage.style.top = 'var(--space-xl)';
                errorMessage.style.right = 'var(--space-xl)';
                errorMessage.style.zIndex = 'var(--z-modal)';
                document.body.appendChild(errorMessage);
                
                setTimeout(() => errorMessage.remove(), 5000);
            } finally {
                submitBtn.classList.remove('saving');
            }
        }

        function populateFormWithData(data) {
            document.getElementById('title').value = data.title || data.name;
            document.getElementById('year').value = (data.release_date || data.first_air_date || '').substring(0, 4);
            document.getElementById('summary').value = data.overview;
            document.getElementById('genre').value = data.genres.map(g => g.name).join(', ');
            document.getElementById('cast').value = data.credits.cast.slice(0, 5).map(c => c.name).join(', ');
            const director = data.credits.crew.find(c => c.job === 'Director');
            document.getElementById('director').value = director ? director.name : '';
            document.getElementById('contentType').value = data.media_type || (data.seasons ? 'tv' : 'movie');
            
            const posterUrl = data.poster_path ? TMDB_IMAGE_BASE + data.poster_path : 'https://placehold.co/300x450/2D194D/DEF0F7?text=No+Poster';
            document.getElementById('movie-poster-img').src = posterUrl;
            
            document.getElementById('movieForm').dataset.tmdbId = data.id;
            document.getElementById('movieForm').dataset.posterUrl = posterUrl;
            document.getElementById('movieForm').dataset.runtime = data.runtime || (data.episode_run_time ? data.episode_run_time[0] : null);

            togglePublicFieldsReadonly(true);
            isPublicFieldsEditable = false;
        }

        function togglePublicFieldsReadonly(isReadonly) {
            const fields = ['title', 'year', 'director', 'genre', 'summary', 'cast', 'contentType'];
            fields.forEach(id => {
                const el = document.getElementById(id);
                if (el.tagName === 'SELECT') el.disabled = isReadonly;
                else el.readOnly = isReadonly;
            });
        }

        function showStatusMessage(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            const iconClass = type === 'success' ? 'icon-confirm' : type === 'error' ? 'icon-close' : 'icon-details';
            statusDiv.innerHTML = `<div class="status-message status-${type}"><span class="icon ${iconClass} icon-md"></span>${message}</div>`;
        }

        function showTimedRedirectModal(title, message, redirectUrl, duration = 5) {
            const modal = document.getElementById('alertModal');
            if (!modal) {
                alert(message);
                setTimeout(() => { window.location.href = redirectUrl; }, 100);
                return;
            }

            const titleEl = modal.querySelector('#alertModalTitle');
            const messageEl = modal.querySelector('#alertModalMessage');
            const okBtn = modal.querySelector('#alertModalOk');
            const closeBtn = modal.querySelector('#alertModalClose');

            titleEl.textContent = title;
            okBtn.style.display = 'inline-flex';
            closeBtn.style.display = 'flex';

            let countdown = duration;
            messageEl.innerHTML = `${message}<br><br>Redirecting in ${countdown} seconds...`;
            modal.classList.add('active');

            const interval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    messageEl.innerHTML = `${message}<br><br>Redirecting in ${countdown} seconds...`;
                } else {
                    clearInterval(interval);
                    window.location.href = redirectUrl;
                }
            }, 1000);

            const cleanup = () => {
                clearInterval(interval);
                modal.classList.remove('active');
            };
            
            okBtn.onclick = () => {
                cleanup();
                window.location.href = redirectUrl;
            };

            closeBtn.onclick = cleanup;
        }
        
        function setupSearch() {
            const searchInput = document.getElementById('movieSearch');
            const searchSpinner = document.getElementById('searchSpinner');
            const searchResultsContainer = document.getElementById('searchResults');
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            
            const debouncedSearch = LibraryUtils.search.createDebouncedSearch((query) => {
                const sanitizedQuery = LibraryUtils.validation.sanitizeInput(query);
                if (sanitizedQuery.length > 2) {
                    performSearch(sanitizedQuery, 1);
                } else {
                    document.getElementById('searchResults').innerHTML = '';
                    document.getElementById('searchFooter').style.display = 'none';
                }
            });
            
            searchInput.addEventListener('input', (e) => {
                debouncedSearch.run(e.target.value);
            });
            
            document.getElementById('searchBtn').addEventListener('click', () => {
                const sanitizedQuery = LibraryUtils.validation.sanitizeInput(searchInput.value);
                performSearch(sanitizedQuery, 1);
            });
            
            loadMoreBtn.addEventListener('click', () => {
                if (isLoadingMore || currentPage >= totalPages) return;
                performSearch(currentSearchQuery, currentPage + 1);
            });
        }

        async function performSearch(query, page = 1) {
            if (!query || isLoadingMore) return;
            
            const isNewSearch = page === 1;
            if (isNewSearch) {
                currentSearchQuery = query;
                currentPage = 1;
            }
            
            isLoadingMore = true;
            
            const cacheKey = `search_${query.toLowerCase().replace(/\s+/g, '_')}_p${page}`;
            const cachedData = apiCache.get('multi-search', cacheKey);
            
            if (cachedData) {
                processAndDisplayResults(cachedData, query, isNewSearch);
                isLoadingMore = false;
                return;
            }
            
            if (isNewSearch) {
                document.getElementById('searchResults').innerHTML = `<div class="loading-container"><div class="loading-spinner" style="display: block;"></div></div>`;
            } else {
                document.getElementById('loadMoreBtn').textContent = 'Loading...';
                document.getElementById('loadMoreBtn').disabled = true;
            }
            
            try {
                const searchUrl = `${TMDB_BASE_URL}/search/multi?query=${encodeURIComponent(query)}&page=${page}`;
                const response = await fetch(searchUrl);
                const data = await response.json();
                
                apiCache.set('multi-search', cacheKey, data);
                processAndDisplayResults(data, query, isNewSearch);
                
            } catch (error) {
                LibraryUtils.errors.handleError(error, 'Search');
                showStatusMessage('Search failed.', 'error');
            } finally {
                isLoadingMore = false;
                const loadMoreBtn = document.getElementById('loadMoreBtn');
                loadMoreBtn.textContent = 'Load More';
                loadMoreBtn.disabled = currentPage >= totalPages;
            }
        }

        function processAndDisplayResults(data, query, isNewSearch) {
            currentPage = data.page;
            totalPages = data.total_pages;
            totalResults = data.total_results;
            
            const results = data.results.filter(item => item.media_type === 'movie' || item.media_type === 'tv')
                .map(item => ({ ...item, score: calculateRelevanceScore(item, query) }))
                .sort((a, b) => b.score - a.score);
            
            displayResults(results, isNewSearch);
            updateUrl(query, currentPage);
            updateSearchFooter();
        }

        function calculateRelevanceScore(item, query) {
            const keywords = query.toLowerCase().split(' ').filter(k => k.length > 2);
            const title = (item.title || item.name || '').toLowerCase();
            const overview = (item.overview || '').toLowerCase();
            let score = 0;
            
            keywords.forEach(keyword => {
                if (title === keyword) score += 100;
                if (title.startsWith(keyword)) score += 50;
                if (title.includes(keyword)) score += 20;
                if (overview.includes(keyword)) score += 5;
            });
            
            const releaseYear = parseInt((item.release_date || item.first_air_date || '').substring(0, 4));
            if (releaseYear > 2020) score += 5;
            score += Math.min(item.popularity / 10, 20);
            score += (item.vote_average || 0) * 2;
            
            return score;
        }

        function displayResults(results, isNewSearch) {
            const resultsDiv = document.getElementById('searchResults');
            if (isNewSearch) {
                resultsDiv.innerHTML = '';
            }
            
            if (results.length === 0 && isNewSearch) {
                resultsDiv.innerHTML = `<div class="empty-state"><span class="icon icon-search icon-3xl"></span><h3>No results found</h3><p>Try adjusting your search terms.</p></div>`;
                return;
            }
            
            const resultsHTML = results.map((item) => {
                const title = item.title || item.name;
                const year = (item.release_date || item.first_air_date || '').substring(0, 4);
                const overview = LibraryUtils.ui.truncateText(item.overview, 100);
                const badgeHTML = item.media_type === 'tv' 
                    ? `<span class="badge badge-tv" title="TV Show"><span class="icon icon-tv icon-sm"></span></span>`
                    : `<span class="badge badge-movie" title="Movie"><span class="icon icon-movie icon-sm"></span></span>`;
                
                return `
                    <div class="search-result" onclick="selectMedia('${item.id}', '${item.media_type}')">
                        <img src="${item.poster_path ? TMDB_IMAGE_BASE + item.poster_path : 'https://placehold.co/50x75/2D194D/DEF0F7?text=N/A'}" 
                             class="search-result-poster" 
                             loading="lazy"
                             onerror="this.style.display='none'">
                        <div class="search-result-info">
                            <h4>${title} (${year}) ${badgeHTML}</h4>
                            <p>${overview}</p>
                        </div>
                    </div>
                `;
            }).join('');
            
            resultsDiv.insertAdjacentHTML('beforeend', resultsHTML);
        }

        function updateSearchFooter() {
            const footer = document.getElementById('searchFooter');
            const countSpan = document.getElementById('resultCount');
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            
            if (totalResults > 0) {
                footer.style.display = 'flex';
                const itemsShown = document.getElementById('searchResults').children.length;
                countSpan.textContent = `Showing ${itemsShown} of ${totalResults} results`;
                
                if (currentPage < totalPages) {
                    loadMoreBtn.style.display = 'block';
                    loadMoreBtn.disabled = false;
                } else {
                    loadMoreBtn.style.display = 'none';
                }
            } else {
                footer.style.display = 'none';
            }
        }

        function updateUrl(query, page) {
            const url = new URL(window.location);
            url.searchParams.set('query', query);
            url.searchParams.set('page', page);
            window.history.pushState({ path: url.href }, '', url.href);
        }

        async function selectMedia(id, type) {
            const selectedResult = event.target.closest('.search-result');
            if (selectedResult) {
                selectedResult.classList.add('selected');
                const allResults = document.querySelectorAll('.search-result');
                allResults.forEach(result => {
                    if (result !== selectedResult) {
                        result.style.opacity = '0.5';
                        result.style.pointerEvents = 'none';
                    }
                });
            }

            showMovieSelectionSkeleton();
            
            const cacheKey = `details_${type}_${id}`;
            const cachedData = apiCache.get('details', cacheKey);
            
            if (cachedData) {
                setTimeout(() => {
                    hideMovieSelectionSkeleton();
                    populateFormWithData(cachedData);
                    clearSearchResults();
                    showStatusMessage('Movie details loaded successfully!', 'success');
                    setTimeout(() => {
                        document.getElementById('statusMessage').innerHTML = '';
                    }, 3000);
                }, 300);
                return;
            }

            try {
                const response = await fetch(`${TMDB_BASE_URL}/${type}/${id}?append_to_response=credits`);
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error('Failed to load movie details');
                }
                
                apiCache.set('details', cacheKey, data);
                hideMovieSelectionSkeleton();
                populateFormWithData(data);
                clearSearchResults();
                
                showStatusMessage('Movie details loaded successfully!', 'success');
                setTimeout(() => {
                    document.getElementById('statusMessage').innerHTML = '';
                }, 3000);
                
            } catch (error) {
                hideMovieSelectionSkeleton();
                if (selectedResult) {
                    selectedResult.classList.remove('selected');
                    const allResults = document.querySelectorAll('.search-result');
                    allResults.forEach(result => {
                        result.style.opacity = '';
                        result.style.pointerEvents = '';
                    });
                }
                
                LibraryUtils.errors.handleError(error, 'Loading media details');
                showStatusMessage('Failed to load movie details. Please try again.', 'error');
            }
        }

        function clearSearchResults() {
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('searchFooter').style.display = 'none';
            document.getElementById('movieSearch').value = '';
            
            currentSearchQuery = '';
            currentPage = 1;
            totalPages = 1;
            totalResults = 0;
            isLoadingMore = false;
        }

        function showMovieSelectionSkeleton() {
            // Hide the real form and show the skeleton UI
            document.getElementById('movieForm').style.display = 'none';
            document.getElementById('form-skeleton').style.display = 'block';
        }

        function hideMovieSelectionSkeleton() {
            // Hide the skeleton UI and show the real form
            document.getElementById('form-skeleton').style.display = 'none';
            document.getElementById('movieForm').style.display = 'block';
        }
        async function setupBarcodeScanner() {
            const cameraBtn = document.getElementById('cameraBtn');
            const manualBtn = document.getElementById('manualBarcodeBtn');
            const lookupBtn = document.getElementById('lookupBarcodeBtn');
            const cancelBtn = document.getElementById('cancelBarcodeBtn');
            const stopBtn = document.getElementById('stop-scanner-btn');
            const barcodeInput = document.getElementById('barcodeInput');
            
            manualBtn.addEventListener('click', showManualInput);
            lookupBtn.addEventListener('click', lookupManualBarcode);
            cancelBtn.addEventListener('click', hideManualInput);
            stopBtn.addEventListener('click', stopScanner);
            
            barcodeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    lookupManualBarcode();
                }
            });
            
            barcodeInput.addEventListener('input', (e) => {
                const value = e.target.value;
                if (!/^\d{0,18}$/.test(value)) {
                    e.target.value = value.replace(/\D/g, '').slice(0, 18);
                }
                document.getElementById('lookupBarcodeBtn').disabled = !LibraryUtils.validation.isValidBarcode(e.target.value);
            });
            
            cameraBtn.addEventListener('click', startScanner);
            
            try {
                if (typeof ZXing !== 'undefined' && ZXing.BrowserMultiFormatReader) {
                    codeReader = new ZXing.BrowserMultiFormatReader();
                    videoInputDevices = await codeReader.listVideoInputDevices();
                    
                    if (videoInputDevices.length === 0) {
                        cameraBtn.disabled = true;
                        cameraBtn.innerHTML = '<span class="icon icon-close icon-md"></span>No Camera';
                    }
                } else {
                    cameraBtn.disabled = true;
                    cameraBtn.innerHTML = '<span class="icon icon-close icon-md"></span>Scanner N/A';
                }
            } catch (err) {
                console.error("Error setting up barcode scanner:", err);
                cameraBtn.disabled = true;
                cameraBtn.innerHTML = '<span class="icon icon-close icon-md"></span>Scanner Error';
            }
        }

        function showManualInput() {
            document.getElementById('manualBarcodeInput').style.display = 'block';
            document.getElementById('barcodeInput').focus();
            document.getElementById('lookupBarcodeBtn').disabled = true;
        }

        function hideManualInput() {
            document.getElementById('manualBarcodeInput').style.display = 'none';
            document.getElementById('barcodeInput').value = '';
        }

        function lookupManualBarcode() {
            const barcode = LibraryUtils.validation.sanitizeInput(document.getElementById('barcodeInput').value);
            if (!LibraryUtils.validation.isValidBarcode(barcode)) {
                showStatusMessage('Please enter a valid barcode (8-18 digits).', 'error');
                return;
            }
            document.getElementById('barcodeSpinner').style.display = 'block';
            lookupMovieByBarcode(barcode).finally(() => {
                hideManualInput();
                document.getElementById('barcodeSpinner').style.display = 'none';
            });
        }

        async function startScanner() {
            if (!codeReader || videoInputDevices.length === 0) return;
            
            document.getElementById('scannerContainer').classList.add('active');
            showStatusMessage('Starting camera...', 'info');
            
            try {
                await codeReader.decodeFromVideoDevice(videoInputDevices[0].deviceId, 'video', (result, err) => {
                    if (result) {
                        stopScanner();
                        lookupMovieByBarcode(result.text);
                    }
                });
                showStatusMessage('Camera ready. Position barcode in view.', 'info');
            } catch (error) {
                LibraryUtils.errors.handleError(error, 'Camera Scanner');
                stopScanner();
            }
        }

        function stopScanner() {
            if (codeReader) codeReader.reset();
            document.getElementById('scannerContainer').classList.remove('active');
        }

    // Fixed UPC lookup function for your existing UPCItemDB API
    async function lookupMovieByBarcode(barcode) {
    console.log('Looking up barcode with UPCItemDB:', barcode);
    
    try {
        showStatusMessage('Looking up barcode...', 'info');
        
        // Call your existing Vercel API endpoint
        const response = await fetch(`/api/upc?upc=${encodeURIComponent(barcode)}`);
        
        // Check if response is ok first
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            throw new Error(errorData.error || `API returned ${response.status}: ${response.statusText}`);
        }
        
        // Parse the JSON response
        const data = await response.json();
        console.log('UPC API Response:', data);
        
        // UPCItemDB API response structure:
        // {
        //   "code": "OK" or "FAIL",
        //   "total": number,
        //   "offset": number,
        //   "items": [
        //     {
        //       "ean": "string",
        //       "title": "string",
        //       "description": "string",
        //       "upc": "string",
        //       "brand": "string",
        //       "model": "string",
        //       "color": "string",
        //       "size": "string",
        //       "dimension": "string",
        //       "weight": "string",
        //       "category": "string",
        //       "currency": "string",
        //       "lowest_recorded_price": number,
        //       "highest_recorded_price": number,
        //       "images": ["string"]
        //     }
        //   ]
        // }
        
        // Validate the response structure
        if (!data || data.code !== 'OK' || !data.items || data.items.length === 0) {
            throw new Error('No product found for this barcode');
        }
        
        // Get the first item from the results
        const product = data.items[0];
        
        if (!product.title) {
            throw new Error('Product found but no title available');
        }
        
        // Extract potential movie/media information
        const title = product.title;
        const description = product.description || 'No description available';
        const category = product.category || '';
        const brand = product.brand || '';
        
        // Try to detect if this is actually a movie/media product
        const isLikelyMedia = category.toLowerCase().includes('movie') || 
                             category.toLowerCase().includes('dvd') || 
                             category.toLowerCase().includes('blu') ||
                             category.toLowerCase().includes('video') ||
                             title.toLowerCase().includes('dvd') ||
                             title.toLowerCase().includes('blu-ray') ||
                             brand.toLowerCase().includes('warner') ||
                             brand.toLowerCase().includes('disney') ||
                             brand.toLowerCase().includes('universal');
        
        // Create TMDB-style data structure
        const mockTmdbData = {
            id: `upc_${barcode}`,
            title: cleanMovieTitle(title), // Clean up title
            name: cleanMovieTitle(title),
            overview: description,
            release_date: extractYearFromTitle(title) || '',
            first_air_date: extractYearFromTitle(title) || '',
            poster_path: product.images && product.images.length > 0 ? product.images[0] : null,
            genres: category ? [{ name: category }] : [],
            credits: {
                cast: [],
                crew: brand ? [{ job: 'Studio', name: brand }] : []
            },
            media_type: 'movie', // Default to movie
            // Store original UPC data for reference
            upcData: {
                brand: brand,
                category: category,
                isLikelyMedia: isLikelyMedia,
                originalTitle: title
            }
        };
        
        populateFormWithData(mockTmdbData);
        
        // Show appropriate success message
        const successMessage = isLikelyMedia 
            ? 'Barcode lookup successful! Movie/media product detected.'
            : 'Barcode lookup successful! Note: This may not be a movie/media product.';
        
        showStatusMessage(successMessage, 'success');
        
        // Store the barcode and UPC data
        document.getElementById('movieForm').dataset.upcCode = barcode;
        document.getElementById('movieForm').dataset.upcBrand = brand;
        document.getElementById('movieForm').dataset.upcCategory = category;
        
        // If it doesn't look like media, offer to search TMDB
        if (!isLikelyMedia) {
            setTimeout(() => {
                if (confirm(`Found product: "${title}"\n\nThis doesn't appear to be a movie/media product. Would you like to search TMDB for a similar title instead?`)) {
                    const searchTerm = cleanMovieTitle(title);
                    document.getElementById('movieSearch').value = searchTerm;
                    performSearch(searchTerm, 1);
                }
            }, 3000);
        }
        
    } catch (error) {
        console.error('UPC lookup failed:', error);
        
        // Show specific error message
        let errorMessage = 'Barcode lookup failed';
        if (error.message.includes('No product found')) {
            errorMessage = 'No product found for this barcode. The barcode may not be in the UPC database.';
        } else if (error.message.includes('API')) {
            errorMessage = `UPC API error: ${error.message}`;
        } else {
            errorMessage = error.message;
        }
        
        showStatusMessage(errorMessage, 'error');
        
        // Offer manual search as fallback
        setTimeout(() => {
            if (confirm('Barcode lookup failed. Would you like to search for this title manually?')) {
                document.getElementById('movieSearch').value = barcode;
                performSearch(barcode, 1);
            }
        }, 2000);
    }
}

    // Helper function to clean movie titles from UPC data
    function cleanMovieTitle(title) {
        if (!title) return '';
        
        // Remove common DVD/Blu-ray suffixes and prefixes
        let cleaned = title
            .replace(/\b(DVD|Blu-ray|Blu Ray|BD)\b/gi, '')
            .replace(/\b(Widescreen|Full Screen|Director's Cut|Extended Edition)\b/gi, '')
            .replace(/\b\d{4}\b/, '') // Remove year if present
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();
        
        // Remove parenthetical information that's not useful
        cleaned = cleaned.replace(/\([^)]*\)/g, '').trim();
        
        return cleaned || title; // Return original if cleaning results in empty string
    }

    // Helper function to extract year from title
    function extractYearFromTitle(title) {
        if (!title) return null;
        
        const yearMatch = title.match(/\b(19|20)\d{2}\b/);
        if (yearMatch) {
            const year = parseInt(yearMatch[0]);
            // Reasonable year range for movies
            if (year >= 1900 && year <= new Date().getFullYear() + 2) {
                return `${year}-01-01`;
            }
        }
        return null;
    }

    // Test function to debug UPC API responses
    window.testUPCLookup = async function(testBarcode = '883929736171') {
        console.log('🔍 Testing UPC lookup with barcode:', testBarcode);
        
        try {
            const response = await fetch(`/api/upc?upc=${testBarcode}`);
            console.log('Response status:', response.status);
            console.log('Response ok:', response.ok);
            
            if (response.ok) {
                const data = await response.json();
                console.log('✅ UPC API Response:', data);
                
                if (data.code === 'OK' && data.items && data.items.length > 0) {
                    console.log('📦 First item:', data.items[0]);
                    console.log('🎬 Title:', data.items[0].title);
                    console.log('📝 Description:', data.items[0].description);
                    console.log('🏷️ Category:', data.items[0].category);
                    console.log('🏢 Brand:', data.items[0].brand);
                } else {
                    console.log('❌ No items found or API returned error');
                }
            } else {
                const errorData = await response.json();
                console.log('❌ API Error:', errorData);
            }
        } catch (error) {
            console.error('💥 Request failed:', error);
        }
    };

// Also fix the constants in your HTML - make sure you have this:
// const UPC_BASE_URL = '/api/upc'; // This should match your Vercel API route    console.log('Looking up barcode:', barcode);
    
    try {
        showStatusMessage('Looking up barcode...', 'info');
        
        // Call your UPC API endpoint
        const response = await fetch(`${UPC_BASE_URL}/lookup?upc=${encodeURIComponent(barcode)}`);
        
        // Check if response is ok first
        if (!response.ok) {
            throw new Error(`UPC API returned ${response.status}: ${response.statusText}`);
        }
        
        // Check content type before parsing
        const contentType = response.headers.get('content-type');
        console.log('Response content type:', contentType);
        
        let data;
        if (contentType && contentType.includes('application/json')) {
            // Parse as JSON
            data = await response.json();
        } else {
            // Handle non-JSON response (HTML, plain text, etc.)
            const textResponse = await response.text();
            console.log('Non-JSON response received:', textResponse.substring(0, 200));
            
            // Try to extract useful information from text response
            // This is a fallback - you might need to adjust based on your actual API response
            if (textResponse.includes('error') || textResponse.includes('not found')) {
                throw new Error('No movie found for this barcode');
            } else if (textResponse.trim() === '') {
                throw new Error('Empty response from UPC API');
            } else {
                // If it's HTML, it might be an error page
                if (textResponse.includes('<html>') || textResponse.includes('<!DOCTYPE')) {
                    throw new Error('UPC API returned an error page. Please check your API endpoint.');
                }
                
                // For plain text responses, try to parse manually
                // You'll need to adjust this based on your API's actual format
                throw new Error('UPC API returned unexpected format. Please check your API configuration.');
            }
        }
        
        // Validate the JSON data structure
        if (!data || typeof data !== 'object') {
            throw new Error('Invalid data format from UPC API');
        }
        
        if (!data.title && !data.name && !data.product_name) {
            throw new Error('No movie title found for this barcode');
        }
        
        // Create mock TMDB-style data from UPC response
        // Adjust these field mappings based on your actual API response structure
        const mockTmdbData = {
            id: `upc_${barcode}`,
            title: data.title || data.name || data.product_name,
            name: data.title || data.name || data.product_name,
            overview: data.description || data.summary || 'No description available',
            release_date: data.year ? `${data.year}-01-01` : (data.release_date || ''),
            first_air_date: data.year ? `${data.year}-01-01` : (data.release_date || ''),
            poster_path: null,
            genres: data.genre ? [{ name: data.genre }] : (data.genres || []),
            credits: {
                cast: data.actors ? 
                      data.actors.split(',').slice(0, 5).map(name => ({ name: name.trim() })) : 
                      (data.cast || []),
                crew: data.director ? 
                      [{ job: 'Director', name: data.director }] : 
                      (data.crew || [])
            },
            media_type: data.media_type || (data.type === 'tv' ? 'tv' : 'movie')
        };
        
        populateFormWithData(mockTmdbData);
        showStatusMessage('Barcode lookup successful!', 'success');
        
        // Store the barcode for later use
        document.getElementById('movieForm').dataset.upcCode = barcode;
        
    } catch (error) {
        console.error('Barcode lookup failed:', error);
        
        // More specific error messages
        let errorMessage = 'Barcode lookup failed';
        if (error.message.includes('fetch')) {
            errorMessage = 'Could not connect to UPC API. Please check your internet connection.';
        } else if (error.message.includes('JSON')) {
            errorMessage = 'UPC API returned invalid data format. Please check your API configuration.';
        } else {
            errorMessage = error.message;
        }
        
        showStatusMessage(errorMessage, 'error');
        
        // Optionally try searching TMDB with the barcode as a query
        setTimeout(() => {
            if (confirm('UPC lookup failed. Would you like to search for this title manually?')) {
                document.getElementById('movieSearch').value = barcode;
                performSearch(barcode, 1);
            }
        }, 2000);
    }

    // Additional debugging function - add this to your HTML file and call this to test your API endpoint
    // Usage: Open browser console and type: testUPCEndpoint('123456789012')
    window.testUPCEndpoint = async function(barcode = '123456789012') {
        console.log('Testing UPC endpoint...');
        
        try {
            const response = await fetch(`${UPC_BASE_URL}/lookup?upc=${barcode}`);
            console.log('Response status:', response.status);
            console.log('Response headers:', [...response.headers.entries()]);
            
            const contentType = response.headers.get('content-type');
            console.log('Content type:', contentType);
            
            if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                console.log('JSON data:', data);
            } else {
                const text = await response.text();
                console.log('Text response (first 500 chars):', text.substring(0, 500));
            }
        } catch (error) {
            console.error('Test failed:', error);
        }
    }

    // Improved error handling for the entire barcode scanning workflow
    function handleBarcodeError(error, context = 'Barcode operation') {
        console.error(`${context} error:`, error);
        
        // Hide any loading spinners
        document.getElementById('barcodeSpinner').style.display = 'none';
        document.getElementById('searchSpinner').style.display = 'none';
        
        // Show user-friendly error message
        let userMessage = 'An error occurred';
        if (error.message.includes('camera')) {
            userMessage = 'Camera error. Please check permissions and try again.';
        } else if (error.message.includes('network') || error.message.includes('fetch')) {
            userMessage = 'Network error. Please check your connection.';
        } else if (error.message.includes('not found')) {
            userMessage = 'No movie found for this barcode.';
        } else if (error.message.includes('API')) {
            userMessage = 'API error. Please try again later.';
        } else {
            userMessage = error.message || 'Unknown error occurred.';
        }
        
        showStatusMessage(userMessage, 'error');
        
        // Reset any selected search results
        const selectedResults = document.querySelectorAll('.search-result.selected');
        selectedResults.forEach(result => {
            result.classList.remove('selected');
            result.style.opacity = '';
            result.style.pointerEvents = '';
        });
    }

// Updated manual barcode lookup with better error handling
function lookupManualBarcode() {
    const barcode = LibraryUtils.validation.sanitizeInput(document.getElementById('barcodeInput').value);
    
    // Improved barcode validation
    if (!barcode || !/^\d{8,18}$/.test(barcode)) {
        showStatusMessage('Please enter a valid barcode (8-18 digits only).', 'error');
        return;
    }
    
    document.getElementById('barcodeSpinner').style.display = 'block';
    document.getElementById('lookupBarcodeBtn').disabled = true;
    
    lookupMovieByBarcode(barcode)
        .catch(error => handleBarcodeError(error, 'Manual barcode lookup'))
        .finally(() => {
            hideManualInput();
            document.getElementById('barcodeSpinner').style.display = 'none';
            document.getElementById('lookupBarcodeBtn').disabled = false;
        });
}
    console.log('Looking up barcode:', barcode);
    
    try {
        showStatusMessage('Looking up barcode...', 'info');
        
        // Call your UPC API endpoint
        const response = await fetch(`${UPC_BASE_URL}/lookup?upc=${encodeURIComponent(barcode)}`);
        const data = await response.json();
        
        if (!response.ok || !data.title) {
            throw new Error('No movie found for this barcode');
        }
        
        // If UPC lookup returns movie data, populate the form
        if (data.title) {
            // Create mock TMDB-style data from UPC response
            const mockTmdbData = {
                id: `upc_${barcode}`,
                title: data.title,
                name: data.title, // For TV shows
                overview: data.description || 'No description available',
                release_date: data.year ? `${data.year}-01-01` : '',
                first_air_date: data.year ? `${data.year}-01-01` : '',
                poster_path: null,
                genres: data.genre ? [{ name: data.genre }] : [],
                credits: {
                    cast: data.actors ? data.actors.split(',').slice(0, 5).map(name => ({ name: name.trim() })) : [],
                    crew: data.director ? [{ job: 'Director', name: data.director }] : []
                },
                media_type: 'movie' // Default to movie
            };
            
            populateFormWithData(mockTmdbData);
            showStatusMessage('Barcode lookup successful!', 'success');
            
            // Set additional barcode-specific data
            document.getElementById('upc-code').value = barcode;
            
        } else {
            throw new Error('No movie information found for this barcode');
        }
        
    } catch (error) {
        console.error('Barcode lookup failed:', error);
        showStatusMessage(`Barcode lookup failed: ${error.message}`, 'error');
        
        // Optionally try searching TMDB with the barcode as a query
        if (confirm('UPC lookup failed. Would you like to search for this title manually?')) {
            document.getElementById('movieSearch').value = barcode;
            performSearch(barcode, 1);
        }
    }


// Fix the scanner setup function:
async function setupBarcodeScanner() {
    const cameraBtn = document.getElementById('cameraBtn');
    const manualBtn = document.getElementById('manualBarcodeBtn');
    const lookupBtn = document.getElementById('lookupBarcodeBtn');
    const cancelBtn = document.getElementById('cancelBarcodeBtn');
    const stopBtn = document.getElementById('stop-scanner-btn');
    const barcodeInput = document.getElementById('barcodeInput');
    
    manualBtn.addEventListener('click', showManualInput);
    lookupBtn.addEventListener('click', lookupManualBarcode);
    cancelBtn.addEventListener('click', hideManualInput);
    stopBtn.addEventListener('click', stopScanner);
    
    barcodeInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            lookupManualBarcode();
        }
    });
    
    barcodeInput.addEventListener('input', (e) => {
        const value = e.target.value;
        if (!/^\d{0,18}$/.test(value)) {
            e.target.value = value.replace(/\D/g, '').slice(0, 18);
        }
        const isValid = LibraryUtils && LibraryUtils.validation 
            ? LibraryUtils.validation.isValidBarcode(e.target.value)
            : e.target.value.length >= 8 && e.target.value.length <= 18;
        document.getElementById('lookupBarcodeBtn').disabled = !isValid;
    });
    
    cameraBtn.addEventListener('click', startScanner);
    
    try {
        if (typeof ZXing !== 'undefined' && ZXing.BrowserMultiFormatReader) {
            codeReader = new ZXing.BrowserMultiFormatReader();
            videoInputDevices = await codeReader.listVideoInputDevices();
            
            if (videoInputDevices.length === 0) {
                cameraBtn.disabled = true;
                cameraBtn.innerHTML = '<span class="icon icon-close icon-md"></span>No Camera';
                console.warn('No camera devices found');
            }
        } else {
            throw new Error('ZXing library not loaded');
        }
    } catch (err) {
        console.error("Error setting up barcode scanner:", err);
        cameraBtn.disabled = true;
        cameraBtn.innerHTML = '<span class="icon icon-close icon-md"></span>Scanner N/A';
    }
}

// Fix the scanner start function:
async function startScanner() {
    if (!codeReader || videoInputDevices.length === 0) {
        showStatusMessage('Camera not available', 'error');
        return;
    }
    
    const modal = document.getElementById('scannerContainer');
    const video = document.getElementById('video'); // Make sure this matches your HTML
    
    modal.classList.add('active');
    showStatusMessage('Starting camera...', 'info');
    
        try {
            // Use the correct video element ID
            await codeReader.decodeFromVideoDevice(
                videoInputDevices[0].deviceId, 
                video, // This should match the ID in your HTML
                (result, err) => {
                    if (result) {
                        console.log('Barcode detected:', result.text);
                        stopScanner();
                        lookupMovieByBarcode(result.text);
                    }
                    // Only log errors that aren't "NotFoundException" (normal when no barcode in view)
                    if (err && !(err instanceof ZXing.NotFoundException)) {
                        console.warn('Scanner error:', err);
                    }
                }
            );
            showStatusMessage('Camera ready. Position barcode in view.', 'info');
        } catch (error) {
            console.error('Failed to start camera:', error);
            showStatusMessage(`Camera error: ${error.message}`, 'error');
            stopScanner();
        }
    }

    // Add validation helper if LibraryUtils isn't available:
    function isValidBarcode(barcode) {
        if (!barcode) return false;
        const cleaned = barcode.replace(/\D/g, '');
        return cleaned.length >= 8 && cleaned.length <= 18;
    }

    // Make sure the stop scanner function works properly:
    function stopScanner() {
        if (codeReader) {
            try {
                codeReader.reset();
            } catch (e) {
                console.warn('Error stopping scanner:', e);
            }
        }
        document.getElementById('scannerContainer').classList.remove('active');
        document.getElementById('statusMessage').innerHTML = '';
    }

        // Mobile-friendly status message improvements
    function showStatusMessage(message, type) {
        const statusDiv = document.getElementById('statusMessage');
        const iconClass = type === 'success' ? 'icon-confirm' : type === 'error' ? 'icon-close' : 'icon-details';
        
        // Create mobile-friendly status message
        statusDiv.innerHTML = `
            <div class="status-message status-${type}" style="
                position: fixed;
                top: var(--space-lg);
                left: var(--space-md);
                right: var(--space-md);
                z-index: var(--z-modal);
                text-align: center;
                font-size: var(--font-size-base);
                padding: var(--space-lg);
                border-radius: var(--radius-lg);
                box-shadow: var(--shadow-lg);
            ">
                <span class="icon ${iconClass} icon-md"></span>
                ${message}
            </div>
        `;
        
        // Auto-dismiss after 4 seconds on mobile
        if (window.innerWidth <= 768) {
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 4000);
        }
    }

    // Mobile-friendly search improvements
    function displayResults(results, isNewSearch) {
        const resultsDiv = document.getElementById('searchResults');
        if (isNewSearch) {
            resultsDiv.innerHTML = '';
        }
        
        if (results.length === 0 && isNewSearch) {
            resultsDiv.innerHTML = `
                <div class="empty-state">
                    <span class="icon icon-search" style="font-size: var(--icon-size-3xl); margin-bottom: var(--space-lg);"></span>
                    <h3>No results found</h3>
                    <p>Try adjusting your search terms or check the spelling.</p>
                </div>
            `;
            return;
        }
        
        const resultsHTML = results.map((item) => {
            const title = item.title || item.name;
            const year = (item.release_date || item.first_air_date || '').substring(0, 4);
            const overview = LibraryUtils.ui.truncateText(item.overview, window.innerWidth <= 480 ? 80 : 100);
            const badgeHTML = item.media_type === 'tv' 
                ? `<span class="badge badge-tv" title="TV Show"><span class="icon icon-tv icon-sm"></span></span>`
                : `<span class="badge badge-movie" title="Movie"><span class="icon icon-movie icon-sm"></span></span>`;
            
            return `
                <div class="search-result" onclick="selectMedia('${item.id}', '${item.media_type}')" style="cursor: pointer;">
                    <img src="${item.poster_path ? TMDB_IMAGE_BASE + item.poster_path : 'https://placehold.co/80x120/2D194D/DEF0F7?text=N/A'}" 
                        class="search-result-poster" 
                        loading="lazy"
                        onerror="this.style.display='none'">
                    <div class="search-result-info">
                        <h4>${title} (${year}) ${badgeHTML}</h4>
                        <p>${overview}</p>
                    </div>
                </div>
            `;
        }).join('');
        
        resultsDiv.insertAdjacentHTML('beforeend', resultsHTML);
    }

    // Mobile-friendly scanner improvements
    async function startScanner() {
        if (!codeReader || videoInputDevices.length === 0) {
            showStatusMessage('Camera not available', 'error');
            return;
        }
        
        const modal = document.getElementById('scannerContainer');
        const video = document.getElementById('video');
        
        modal.classList.add('active');
        
        // Mobile-specific scanner message
        const isMobile = window.innerWidth <= 768;
        showStatusMessage(
            isMobile ? 'Starting camera... Hold phone steady and position barcode in center of screen.' : 'Starting camera...', 
            'info'
        );
        
        try {
            await codeReader.decodeFromVideoDevice(
                videoInputDevices[0].deviceId, 
                video,
                (result, err) => {
                    if (result) {
                        console.log('Barcode detected:', result.text);
                        
                        // Provide haptic feedback on mobile if available
                        if (navigator.vibrate) {
                            navigator.vibrate(200);
                        }
                        
                        stopScanner();
                        lookupMovieByBarcode(result.text);
                    }
                    if (err && !(err instanceof ZXing.NotFoundException)) {
                        console.warn('Scanner error:', err);
                    }
                }
            );
            
            showStatusMessage(
                isMobile ? 'Camera ready. Center barcode in view and hold steady.' : 'Camera ready. Position barcode in view.',
                'info'
            );
        } catch (error) {
            console.error('Failed to start camera:', error);
            showStatusMessage(`Camera error: ${error.message}. Please ensure camera permissions are granted.`, 'error');
            stopScanner();
        }
    }

    // Improved form validation for mobile
    function validateFormOnMobile() {
        const titleValue = document.getElementById('title').value.trim();
        if (!titleValue) {
            showStatusMessage('Please search for and select a movie first.', 'error');
            
            // Scroll to search section on mobile
            if (window.innerWidth <= 768) {
                document.querySelector('.search-section').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }
            return false;
        }
        return true;
    }

    // Mobile-friendly modal improvements
    function showTimedRedirectModal(title, message, redirectUrl, duration = 5) {
        const modal = document.getElementById('alertModal');
        if (!modal) {
            alert(message);
            setTimeout(() => { window.location.href = redirectUrl; }, 100);
            return;
        }

        const titleEl = modal.querySelector('#alertModalTitle');
        const messageEl = modal.querySelector('#alertModalMessage');
        const okBtn = modal.querySelector('#alertModalOk');
        const closeBtn = modal.querySelector('#alertModalClose');

        titleEl.textContent = title;
        okBtn.style.display = 'inline-flex';
        closeBtn.style.display = 'flex';

        let countdown = duration;
        const isMobile = window.innerWidth <= 768;
        
        messageEl.innerHTML = isMobile 
            ? `${message}<br><br><strong>Redirecting in ${countdown}s...</strong>`
            : `${message}<br><br>Redirecting in ${countdown} seconds...`;
        
        modal.classList.add('active');

        const interval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
                messageEl.innerHTML = isMobile 
                    ? `${message}<br><br><strong>Redirecting in ${countdown}s...</strong>`
                    : `${message}<br><br>Redirecting in ${countdown} seconds...`;
            } else {
                clearInterval(interval);
                window.location.href = redirectUrl;
            }
        }, 1000);

        const cleanup = () => {
            clearInterval(interval);
            modal.classList.remove('active');
        };
        
        okBtn.onclick = () => {
            cleanup();
            window.location.href = redirectUrl;
        };

        closeBtn.onclick = cleanup;
        
        // Close modal on background tap for mobile
        modal.onclick = (e) => {
            if (e.target === modal) {
                cleanup();
            }
        };
    }

    // Add touch event improvements for mobile
    document.addEventListener('DOMContentLoaded', () => {
        // Improve touch targets on mobile
        if (window.innerWidth <= 768) {
            const style = document.createElement('style');
            style.textContent = `
                .search-result {
                    min-height: 60px;
                    touch-action: manipulation;
                }
                .btn {
                    touch-action: manipulation;
                }
                .star-rating-interactive .star {
                    touch-action: manipulation;
                    padding: var(--space-xs);
                }
            `;
            document.head.appendChild(style);
        }
        
        // Prevent zoom on input focus for iOS
        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
            const inputs = document.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
                if (parseFloat(getComputedStyle(input).fontSize) < 16) {
                    input.style.fontSize = '16px';
                }
            });
        }
    });

    </script>
    <footer id="footer-placeholder"></footer>
</body>
</html>
