<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=5.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#24143E">
    <title>bulk scan - the library sale</title>
    
    <!-- Google Fonts Import -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=B612+Mono&family=Dokdo&family=Kirang+Haerang&family=M+PLUS+2&family=Syne+Mono&display=swap" rel="stylesheet">
    
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-auth-compat.js"></script>
    
    <!-- ZXing Barcode Scanner Library -->
    <script type="text/javascript" src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>
    
    <!-- App Utilities -->
    <script src="utils.js"></script>
    <script src="modal-manager.js"></script>
    <script src="scanner-utils.js"></script>
    <script src="cache.js"></script>
    <script src="search-ui.js"></script> 

    <!-- Styles -->
    <link rel="stylesheet" href="styles/variables.css">
    <link rel="stylesheet" href="styles/base.css">  
    <link rel="stylesheet" href="styles/components.css">
    <link rel="stylesheet" href="styles/pages.css">
    
    <!-- Main Script -->
    <script src="main.js" defer></script>
</head>
<body>
    <header id="navbar-placeholder"></header>

    <main class="bulk-scan-container">
        <!-- Hero Section -->
        <section class="hero-section">
            <h1 id="bulkScanTitle">scan the stacks</h1>
            <p class="hero-subtitle">scan multiple barcodes</p>
        </section>

        <!-- Scanner Section -->
        <section id="scannerSection" class="scanner-section" style="display: none;">
            <div class="scanner-viewport-bulk">
                <video id="scanner-video" autoplay muted playsinline></video>
                <div class="scanner-guideline"></div>
                <div id="scanResultIndicator" class="scan-result-indicator">
                    <span id="scanResultIcon" class="icon"></span>
                    <p id="scanResultText"></p>
                </div>
                <div class="scanner-status" id="scannerStatus">position barcode in center</div>
            </div>
            
            <!-- Quick Action Buttons -->
            <div class="quick-actions">
                <button id="skipBtn" class="btn btn-rectangular btn-secondary">skip current</button>
                <button id="manualEntryBtn" class="btn btn-rectangular btn-primary">manual entry</button>
            </div>
        </section>
        <section>
        <div class="scan-actions">
            <button id="startScanBtn" class="btn-rectangular btn-success" title="start scanning">
                <span class="icon icon-bulk icon-xl"></span>
            </button>
            <button id="finishScanBtn" class="btn btn-xl btn-success" style="display: none;" title="finish and review">
                <span class="icon icon-confirm icon-xl"></span>
            </button>
        </div>
    </section>

        <!-- Results Section -->
        <section class="results-section">
            <div class="section-title">
                <h3>scan results</h3>
                <div class="compact-stats">
                    <span class="compact-stat">
                        <span id="compactScannedCount">0</span> scanned
                    </span>
                    <span class="compact-stat-separator">•</span>
                    <span class="compact-stat">
                        <span id="compactFoundCount">0</span> found
                    </span>
                    <span class="compact-stat-separator">•</span>
                    <span class="compact-stat">
                        <span id="compactFailedCount">0</span> failed
                    </span>
                </div>
            </div>
            <p class="section-subtitle" id="resultsSubtitle">items will appear here as you scan</p>
            
            <!-- Filter Tabs -->
            <div class="result-filters">
                <button class="filter-btn active" data-filter="all">all (<span id="allCount">0</span>)</button>
                <button class="filter-btn" data-filter="found">found (<span id="foundTabCount">0</span>)</button>
                <button class="filter-btn" data-filter="needs_review">needs review (<span id="needsReviewTabCount">0</span>)</button>
                <button class="filter-btn" data-filter="skipped">skipped (<span id="skippedTabCount">0</span>)</button>
                <button class="filter-btn" data-filter="failed">failed (<span id="failedTabCount">0</span>)</button>
            </div>
            
            <!-- Results Grid -->
            <div id="resultsGrid" class="bulk-results-grid">
                <div class="empty-state">
                    <span class="icon icon-add icon-4xl"></span>
                    <h3>ready to scan</h3>
                    <p>start scanning barcodes to see here</p>
                </div>
            </div>
        </section>

        <!-- Updated Final Actions section for bulk-scan.html -->
        <section id="finalActions" class="final-actions" style="display: none;">
            <h2>review and save</h2>
            <div class="final-stats">
                <p><strong id="finalFoundCount">0</strong> items found and ready to add</p>
                <p><strong id="finalNeedsReviewCount">0</strong> items need manual review</p>
                <p><strong id="finalSkippedCount">0</strong> duplicates skipped by choice</p>
                <p><strong id="finalFailedCount">0</strong> items failed (you can add these manually later)</p>
            </div>
            <div class="final-buttons">
                <button id="addAllBtn" class="btn btn-xl btn-success" title="add all found">
                    <span class="icon icon-confirm icon-xl"></span>
                </button>
                <button id="reviewItemsBtn" class="btn btn-xl btn-warning" title="review items">
                    <span class="icon icon-details icon-xl"></span>
                </button>
                <button id="startOverBtn" class="btn btn-xl btn-danger" title="start over">
                    <span class="icon icon-delete icon-xl"></span>
                </button>
            </div>

            <!-- Keyboard Shortcuts Hint -->
            <div id="keyboardHints" class="keyboard-hints hidden">
                <div><strong>shortcuts:</strong></div>
                <div>esc: finish scanning</div>
                <div>M: manual entry</div>
            </div>

            <!-- Progress Bar -->
            <div id="scanProgress" class="scan-progress" style="display: none;">
                <div id="scanProgressBar" class="scan-progress-bar"></div>
            </div>
        </section>
    </main>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDDW8LtwpYevdkD7Q-_CxJ23mMfi00P21M",
            authDomain: "tiny-lizard.firebaseapp.com",
            projectId: "tiny-lizard",
            storageBucket: "tiny-lizard.firebasestorage.app",
            messagingSenderId: "250872474692",
            appId: "1:250872474692:web:969e0b1302ae3cb4666011",
        };
        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore(); 
        const auth = firebase.auth();

        // Global variables
        let currentUser = null;
        let bulkScanner = null;
        
        // Scan results storage
        let scanResults = [];
        let currentFilter = 'all';
        let processedBarcodes = new Set(); // Prevent duplicates

        //Add a processing queue
        const scanQueue = [];
        let isProcessingQueue = false;
        const PROCESS_INTERVAL = 500; // Process one item every .5 seconds (500ms). Adjust as needed.

        
        const apiCache = new CacheManager('bulk_scan_cache_', 50, 2); // 2 hour cache for bulk scanning
        const TMDB_BASE_URL = '/api/tmdb';
        const UPC_BASE_URL = '/api/upc';
        const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';

async function initializeBulkScanner() {
    setupEventListeners();

    bulkScanner = new ScannerManager({
        continuous: true,
        allowDuplicates: false, // Manager will prevent re-processing the same barcode
        pauseBetweenScans: 4000, 
        onBarcodeScanned: processBarcodeResult, // Use our function as the callback
        onStatusUpdate: updateScannerStatus,
        onError: (message) => LibraryUtils.ui.showStatusMessage(message, 'error'),
    });

    setInterval(() => {
        if (bulkScanner) {
            bulkScanner.cleanupStaleProcessing();
        }
    }, 10000); // Every 10 seconds

        ScannerUI.initialize(async (barcode) => { 
            await bulkScanner.addManualBarcode(barcode);
            return true;
        });

    document.getElementById('resultsGrid').addEventListener('click', (e) => {
        const removeBtn = e.target.closest('.btn-remove-item');
        if (removeBtn) {
            const resultId = parseFloat(removeBtn.dataset.resultId);
            removeResult(resultId);
        }
    });

    // Find your event listener for 'manualEntryBtn' and simplify it
    document.getElementById('manualEntryBtn').addEventListener('click', () => {
        ScannerUI.showManualEntryModal();
    });

    const initialized = await bulkScanner.initialize();
    if (!initialized) {
        LibraryUtils.ui.showStatusMessage('Camera scanner not available.', 'error');
        document.getElementById('startScanBtn').disabled = true;
    }

    restoreProgress();
}
    function setupEventListeners() {
        document.getElementById('startScanBtn').addEventListener('click', startBulkScanning);
        document.getElementById('finishScanBtn').addEventListener('click', finishScanning);
        document.getElementById('addAllBtn').addEventListener('click', addAllToLibrary);
        document.getElementById('startOverBtn').addEventListener('click', startOver);

        // NEW: Add review button listener with safety check
        const reviewItemsBtn = document.getElementById('reviewItemsBtn');
        if (reviewItemsBtn) {
            reviewItemsBtn.addEventListener('click', initiateReview);
        }

        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => setResultFilter(btn.dataset.filter));
        });

        document.getElementById('resultsGrid').addEventListener('click', (e) => {
            const removeBtn = e.target.closest('.btn-remove-item');
            if (removeBtn) {
                const resultId = parseFloat(removeBtn.dataset.resultId);
                removeResult(resultId);
            }
        });

        document.getElementById('manualEntryBtn').addEventListener('click', () => {
            ScannerUI.showManualEntryModal();
        });
    }
    function showScanIndicator(status, message) {
            const indicator = document.getElementById('scanResultIndicator');
            const icon = document.getElementById('scanResultIcon');
            const text = document.getElementById('scanResultText');

            if (status === 'success') {
                indicator.className = 'scan-result-indicator show success';
                icon.className = 'icon icon-confirm';
            } else {
                indicator.className = 'scan-result-indicator show error';
                icon.className = 'icon icon-close';
            }
            text.textContent = message;

            // Hide the indicator just before the scanner becomes active again
            setTimeout(() => {
                indicator.className = 'scan-result-indicator';
            }, 2800); // Slightly less than the 3000ms pause
    }
//Create a function to process the queue
async function processScanQueue() {
    if (isProcessingQueue || scanQueue.length === 0) {
        isProcessingQueue = false;
        return; // Stop if nothing to process or already running
    }

    isProcessingQueue = true;
    const barcode = scanQueue.shift(); // Get the oldest barcode from the queue

    // Update the UI to show that we are processing from the queue
    updateScannerStatus(`Processing ${barcode} from queue... (${scanQueue.length} left)`, 'processing');
    
    // The entire logic should be inside the try...catch block
    try {
        // This is the single call to our lookup function
        await processBarcodeLookup(barcode);
        
        // If successful, continue at the normal speed
        setTimeout(processScanQueue, PROCESS_INTERVAL);

    } catch (error) {
        if (error.message === 'RATE_LIMIT') {
            // WHOOPS! We hit the limit.
            // 1. Put the barcode back at the front of the queue to be retried.
            scanQueue.unshift(barcode); 
            
            // 2. Wait for a longer "penalty" period (e.g., 10 seconds).
            const PENALTY_BOX_TIME = 10000;
            updateScannerStatus(`Rate limit hit. Pausing for 10s...`, 'warning');
            
            // 3. Resume the queue after the pause.
            setTimeout(processScanQueue, PENALTY_BOX_TIME);

        } else {
            // For any other error, log it and continue the queue normally.
            console.error("An error occurred during barcode lookup:", error);
            setTimeout(processScanQueue, PROCESS_INTERVAL);
        }
    }    
}
function saveReviewQueue() {
    const queueData = {
        queue: reviewQueue,
        timestamp: Date.now(),
        expiresAt: Date.now() + (24 * 60 * 60 * 1000) // 24 hours
    };
    
    try {
        sessionStorage.setItem('reviewQueue', JSON.stringify(queueData));
        // Also backup to localStorage for longer persistence
        localStorage.setItem('reviewQueue_backup', JSON.stringify(queueData));
    } catch (e) {
        console.warn('Could not save review queue:', e);
    }
}
async function addMovieToDatabase(result) {
    const { tmdbData, upcData, physicalEdition } = result;
    
    try {
        let movieDocRef;
        
        // FIXED: Use CachedFirestore instead of direct calls
        if (tmdbData.id && !`${tmdbData.id}`.startsWith('upc_')) {
            const existingDoc = await CachedFirestore.getMovieByTmdbId(tmdbData.id);
            if (existingDoc.exists) {
                movieDocRef = { id: existingDoc.id };
            }
        }

        // Create new movie if doesn't exist
        if (!movieDocRef) {
            const movieData = {
                title: tmdbData.title || tmdbData.name,
                year: tmdbData.release_date ? parseInt(tmdbData.release_date.substring(0, 4)) : null,
                director: tmdbData.credits?.crew?.find(c => c.job === 'Director')?.name || '',
                genre: tmdbData.genres?.map(g => g.name).join(', ') || '',
                posterUrl: tmdbData.poster_path ? MediaLookupUtils.TMDB_IMAGE_BASE + tmdbData.poster_path : null,
                runtime: tmdbData.runtime || null,
                tmdbId: tmdbData.id && !`${tmdbData.id}`.startsWith('upc_') ? parseInt(tmdbData.id) : null,
                overview: tmdbData.overview || '',
                cast: tmdbData.credits?.cast?.slice(0, 5).map(c => c.name) || [],
                contentType: tmdbData.media_type || (tmdbData.seasons ? 'tv' : 'movie'),
                dateAdded: firebase.firestore.FieldValue.serverTimestamp(),
                originalUploaderId: currentUser.uid,
                originalUploaderDisplayName: currentUser.displayName || currentUser.email,
                isManualEntry: false,
            };
            
            movieDocRef = await db.collection('movies').add(movieData);
            
            //Cache the new movie
            CachedFirestore.cacheMovie(movieDocRef.id, movieData, movieData.tmdbId);
        }

        // Handle physical copy creation
        let physicalCopyId = null;
        if (physicalEdition && upcData.barcode) {
            const uniqueId = MediaLookupUtils.generateUniqueIdentifier(
                upcData.barcode,
                physicalEdition.format,
                physicalEdition.edition,
                physicalEdition.region
            );

            // Check if physical copy exists
            const existingCopy = await MediaLookupUtils.findExistingPhysicalCopy(uniqueId);

            if (existingCopy) {
                physicalCopyId = existingCopy.id;
            } else {
                // Create new physical copy
                physicalCopyId = await MediaLookupUtils.createPhysicalCopy(
                    movieDocRef.id,
                    {
                        ...physicalEdition,
                        barcode: upcData.barcode
                    },
                    currentUser.uid
                );
            }
        }
        
        return { 
            movieDocRef, 
            physicalCopyId,
            processed: true
        };
        
    } catch (error) {
        console.error('Error in addMovieToDatabase:', error);
        throw error;
    }
}

// Function to handle final bulk save with proper duplicate detection
async function saveFoundItemsToUserLibrary(foundResults) {
    let successCount = 0;
    let duplicateCount = 0;
    let errorCount = 0;
    
    for (const result of foundResults) {
        try {
            // Get the movie that was already created during scanning
            const movieId = result.movieDocRef?.id;
            if (!movieId) {
                throw new Error('Movie reference missing');
            }
            
            // Check for existing user interaction
            const userInteractionRef = db.collection('users').doc(currentUser.uid)
                .collection('movieInteractions').doc(movieId);
            const existingInteraction = await userInteractionRef.get();
            
            if (existingInteraction.exists) {
                const existingData = existingInteraction.data();
                const currentPhysicalCopies = existingData.physicalCopies || [];
                
                // Check if user already owns this physical copy
                if (result.physicalCopyId && currentPhysicalCopies.includes(result.physicalCopyId)) {
                    // Ask user about duplicate
                    const currentCount = currentPhysicalCopies.filter(id => id === result.physicalCopyId).length;
                    const shouldAddAnyway = await showDuplicateConfirmation(
                        result.tmdbData.title || result.tmdbData.name,
                        result.physicalEdition.format,
                        result.physicalEdition.edition,
                        currentCount
                    );
                    
                    if (!shouldAddAnyway) {
                        duplicateCount++;
                        continue; // Skip this item
                    }
                }
                
                // Update existing interaction - add physical copy
                const updatedPhysicalCopies = [...currentPhysicalCopies];
                if (result.physicalCopyId) {
                    updatedPhysicalCopies.push(result.physicalCopyId);
                }
                
                await userInteractionRef.update({
                    physicalCopies: updatedPhysicalCopies,
                    owned: true,
                    upc: result.upcData?.barcode || existingData.upc || '',
                    physicalEdition: result.physicalEdition || existingData.physicalEdition || {}
                });
            } else {
                // Create new user interaction
                const userInteractionData = {
                    movieId: movieId,
                    rating: 0,
                    review: "",
                    watched: false,
                    watchedDate: null,
                    owned: true,
                    interactionDate: firebase.firestore.FieldValue.serverTimestamp(),
                    physicalCopies: result.physicalCopyId ? [result.physicalCopyId] : [],
                    upc: result.upcData?.barcode || '',
                    physicalEdition: result.physicalEdition || {}
                };

                await userInteractionRef.set(userInteractionData);
            }
            
            successCount++;
            
        } catch (error) {
            console.error('Failed to save item to user library:', error);
            errorCount++;
        }
    }
    
    return { successCount, duplicateCount, errorCount };
}
async function addMovieToDatabase_WithDuplicateHandling(result) {
    try {
        return await addMovieToDatabase(result);
    } catch (error) {
        if (error.message === 'DUPLICATE_CHECK_NEEDED') {
            // Handle duplicate confirmation outside transaction
            const { tmdbData, physicalEdition } = result;
            const shouldAddAnyway = await showDuplicateConfirmation(
                tmdbData.title || tmdbData.name,
                physicalEdition.format,
                physicalEdition.edition,
                1 // You'd need to calculate current count
            );
            
            if (!shouldAddAnyway) {
                throw new Error('DUPLICATE_SKIPPED');
            }
            
            // If user confirms, run a simpler transaction that just adds the copy
            return await addDuplicatePhysicalCopy(result);
        }
        throw error;
    }
}
function startOver() {
    if (confirm('Are you sure you want to start over? All scanned results will be lost.')) {
        // Clear everything
        scanResults = [];
        processedBarcodes.clear();
        currentFilter = 'all';
        
        // Clear localStorage
        localStorage.removeItem('bulkScanProgress');
        
        // Reset UI
        updateStats();
        renderResults();
        setResultFilter('all');
        
        document.getElementById('finalActions').style.display = 'none';
        finishScanning();
        
        LibraryUtils.ui.showStatusMessage('Started fresh scan session', 'info');
    }
}
//Function to show a toast notification
function showToastNotification(message, status = 'info') {
    // Create the toast element
    const toast = document.createElement('div');
    toast.className = `toast-notification ${status}`;

    // Create an icon
    const icon = document.createElement('span');
    const iconName = {
        success: 'icon-confirm',
        error: 'icon-close',
        warning: 'icon-info', // Using info icon for warning
        info: 'icon-info'
    }[status];
    icon.className = `icon ${iconName}`;

    // Create the text
    const text = document.createElement('p');
    text.textContent = message;

    // Assemble the toast
    toast.appendChild(icon);
    toast.appendChild(text);

    // Add it to the page
    document.body.appendChild(toast);

    // The toast will remove itself after the CSS animation finishes (4 seconds)
    toast.addEventListener('animationend', () => {
        toast.remove();
    });
}

        // Enhanced keyboard shortcuts with hints
        document.addEventListener('keydown', (e) => {
            // Check the scanner's state directly from the manager object
            if (bulkScanner && bulkScanner.getStats().isScanning) {
                if (e.code === 'Escape') {
                    e.preventDefault();
                    finishScanning();
                }
            }

                // Use the new centralized modal function for manual entry
            if (e.code === 'KeyM' && !document.querySelector('.modal.active')) {
                e.preventDefault();
                ScannerUI.showManualEntryModal();
            }
        });
        // Show/hide keyboard hints based on scanning state
        function updateKeyboardHints() {
            const hints = document.getElementById('keyboardHints');
            // FIX: Check the scanning state from the bulkScanner manager instance
            if (bulkScanner && bulkScanner.getStats().isScanning) {
                hints.classList.remove('hidden');
            } else {
                hints.classList.add('hidden');
            }
        }
        // Update progress bar during bulk operations
        function updateProgressBar(current, total) {
            const progressContainer = document.getElementById('scanProgress');
            const progressBar = document.getElementById('scanProgressBar');
            
            if (current > 0 && total > 0) {
                const percentage = (current / total) * 100;
                progressBar.style.width = `${percentage}%`;
                progressContainer.style.display = 'block';
            } else {
                progressContainer.style.display = 'none';
            }
        }
        // Auto-save progress to localStorage
        function saveProgress() {
            if (scanResults.length > 0) {
                localStorage.setItem('bulkScanProgress', JSON.stringify({
                    results: scanResults,
                    processedBarcodes: Array.from(processedBarcodes),
                    timestamp: Date.now()
                }));
            }
        }
        // Auto-save every 5 seconds
        setInterval(saveProgress, 5000);
        // Also save on major actions
        function saveProgressOnAction() {
            setTimeout(saveProgress, 100);
        }
        // Restore progress on page load
        function restoreProgress() {
            const saved = localStorage.getItem('bulkScanProgress');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    const age = Date.now() - data.timestamp;
                    
                    // Only restore if less than 1 hour old
                    if (age < 3600000 && data.results && data.results.length > 0) {
                        if (confirm(`Found ${data.results.length} items from a previous scanning session. Restore them?`)) {
                            scanResults = data.results;
                            processedBarcodes = new Set(data.processedBarcodes || data.results.map(r => r.barcode));
                            updateStats();
                            renderResults();
                            LibraryUtils.ui.showStatusMessage('Previous session restored!', 'success');
                        } else {
                            localStorage.removeItem('bulkScanProgress');
                        }
                    }
                } catch (e) {
                    console.error('Failed to restore scan progress:', e);
                    localStorage.removeItem('bulkScanProgress');
                }
            }
        }
    async function startBulkScanning() {
        if (!bulkScanner || !bulkScanner.getStats().hasCamera) {
            LibraryUtils.ui.showStatusMessage('Camera not available', 'error');
            return;
        }

        // Update UI
        document.getElementById('scannerSection').style.display = 'block';
        document.getElementById('startScanBtn').style.display = 'none';
        document.getElementById('finishScanBtn').style.display = 'inline-flex';
        updateKeyboardHints();

        const video = document.getElementById('scanner-video');
        await bulkScanner.startCamera(video, 'scannerStatus');
        }
async function processBarcodeLookup(barcode) {
    if (scanResults.some(r => r.barcode === barcode)) {
        console.log(`Barcode ${barcode} already in results, skipping`);
        showScanIndicator('warning', 'Already processed');
        return;
    }

    processedBarcodes.add(barcode);
    updateStats();

    try {
        updateScannerStatus(`Looking up ${barcode}...`, 'processing');
        
        const lookupResult = await MediaLookupUtils.completeMovieLookup(barcode);
        const { upcData, tmdbData, physicalEdition, confidence, needsReview } = lookupResult;

        const dbResult = await addMovieToDatabase(lookupResult);
            
        let status = 'found';
        if (needsReview) {
            status = 'needs_review';
        }

        const scanResult = {
            id: Date.now() + Math.random(),
            barcode: barcode,
            status: status,
            timestamp: new Date(),
            upcData,
            tmdbData,
            title: tmdbData.title || tmdbData.name,
            year: (tmdbData.release_date || tmdbData.first_air_date || '').substring(0, 4),
            poster: tmdbData.poster_path ? MediaLookupUtils.TMDB_IMAGE_BASE + tmdbData.poster_path : null,
            physicalEdition,
            confidence: confidence || 0,
            movieDocRef: dbResult.movieDocRef,
            physicalCopyId: dbResult.physicalCopyId
        };


        scanResults.push(scanResult);
        
        if (status === 'needs_review') {
            showToastNotification(`Needs Review: ${scanResult.title}`, 'warning');
        } else {
            showToastNotification(`Found: ${scanResult.title}`, 'success');
        }
        
    } catch (error) {
        console.error('Failed to process barcode:', barcode, error);
        const failedResult = {
            id: Date.now() + Math.random(),
            barcode: barcode,
            status: 'failed',
            timestamp: new Date(),
            error: error.message,
            title: `Unknown (${barcode})`,
            year: '',
            poster: null
        };
        
        scanResults.push(failedResult);
        showToastNotification(`Failed: ${error.message}`, 'error');
    }

    updateStats();
    renderResults();
    saveProgressOnAction();
}
async function processBarcodeResult(barcode) {
    // 1. Check if barcode has already been queued or processed
    if (processedBarcodes.has(barcode) || scanQueue.includes(barcode)) {
        console.log(`Barcode ${barcode} already in queue/results, skipping.`);
        showScanIndicator('warning', 'Already queued');
        return;
    }

    // 2. Add the new barcode to our records and the queue
    processedBarcodes.add(barcode);
    scanQueue.push(barcode);
    showScanIndicator('success', `Queued (${scanQueue.length})`);
    updateScannerStatus(`${scanQueue.length} item(s) in queue`, 'info');
    
    // 3. Start the queue processor if it's not already running
    if (!isProcessingQueue) {
        processScanQueue();
    }
}        
function updateScannerStatus(message, type = 'info') {
            const statusEl = document.getElementById('scannerStatus');
            statusEl.textContent = message;
            statusEl.className = `scanner-status status-${type}`;
        }

        function updateStats() {
    const scannedCount = scanResults.length;
    const foundCount = scanResults.filter(r => r.status === 'found').length;
    const needsReviewCount = scanResults.filter(r => r.status === 'needs_review').length;
    const failedCount = scanResults.filter(r => r.status === 'failed').length;
    const skippedCount = scanResults.filter(r => r.status === 'skipped').length;
    
    // Update compact stats (new)
    document.getElementById('compactScannedCount').textContent = scannedCount;
    document.getElementById('compactFoundCount').textContent = foundCount;
    document.getElementById('compactFailedCount').textContent = failedCount;
    
    // Update filter tabs
    document.getElementById('allCount').textContent = scannedCount;
    document.getElementById('foundTabCount').textContent = foundCount;
    document.getElementById('needsReviewTabCount').textContent = needsReviewCount;
    document.getElementById('failedTabCount').textContent = failedCount;
    
    // Add skipped count if element exists
    const skippedTabElement = document.getElementById('skippedTabCount');
    if (skippedTabElement) {
        skippedTabElement.textContent = skippedCount;
    }

    // Update final stats
    document.getElementById('finalFoundCount').textContent = foundCount;
    document.getElementById('finalFailedCount').textContent = failedCount;

    const finalNeedsReviewElement = document.getElementById('finalNeedsReviewCount');
    if (finalNeedsReviewElement) {
        finalNeedsReviewElement.textContent = needsReviewCount;
    }
    
    const finalSkippedElement = document.getElementById('finalSkippedCount');
    if (finalSkippedElement) {
        finalSkippedElement.textContent = skippedCount;
    }

    // Show/hide review button only if it exists
    const reviewBtn = document.getElementById('reviewItemsBtn');
    if (reviewBtn) {
        reviewBtn.style.display = needsReviewCount > 0 ? 'inline-flex' : 'none';
    }   
}


// Helper function to count how many of the same copy type user has
function getCurrentCopyCount(physicalCopiesArray, targetCopyId) {
return physicalCopiesArray.filter(copyId => copyId === targetCopyId).length;
}

// Show duplicate confirmation modal
async function showDuplicateConfirmation(movieTitle, format, edition, currentCount) {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'modal active';
        modal.innerHTML = `
            <div class="modal-content">
                <h3>Duplicate Copy Detected</h3>
                <p>You already own <strong>${currentCount}</strong> copy/copies of:</p>
                <div class="duplicate-copy-details">
                    <h4>${movieTitle}</h4>
                    <p><strong>${format}</strong> • ${edition}</p>
                </div>
                <p>Do you want to add another copy anyway?</p>
                <div class="modal-buttons">
                    <button id="addAnywayBtn" class="btn btn-lg btn-success" title="Add Another Copy">
                        <span class="icon icon-confirm icon-lg"></span>
                        Add Anyway
                    </button>
                    <button id="skipDuplicateBtn" class="btn btn-lg btn-secondary" title="Skip This Copy">
                        <span class="icon icon-close icon-lg"></span>
                        Skip
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        const addBtn = modal.querySelector('#addAnywayBtn');
        const skipBtn = modal.querySelector('#skipDuplicateBtn');
        
        const cleanup = () => {
            modal.remove();
        };
        
        addBtn.addEventListener('click', () => {
            cleanup();
            resolve(true);
        });
        
        skipBtn.addEventListener('click', () => {
            cleanup();
            resolve(false);
        });
        
        // Close on backdrop click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                cleanup();
                resolve(false);
            }
        });
    });
}

// addAllToLibrary to handle only found items (skip the skipped ones)
async function addAllToLibrary() {
    const foundResults = scanResults.filter(r => r.status === 'found');
    
    if (foundResults.length === 0) {
        LibraryUtils.ui.showStatusMessage('No items found to add', 'warning');
        return;
    }
    
    const addAllBtn = document.getElementById('addAllBtn');
    addAllBtn.classList.add('saving');
    addAllBtn.disabled = true;
    
    try {
        // Use the new save function that handles duplicates properly
        const results = await saveFoundItemsToUserLibrary(foundResults);
        const { successCount, duplicateCount, errorCount } = results;
        
        // Clear localStorage progress
        localStorage.removeItem('bulkScanProgress');

        let message = `Added ${successCount} items to your library.`;
        if (duplicateCount > 0) {
            message += ` ${duplicateCount} duplicates were skipped.`;
        }
        if (errorCount > 0) {
            message += ` ${errorCount} failed.`;
        }
        
        LibraryUtils.ui.showStatusMessage(message, errorCount > 0 ? 'warning' : 'success');

    // Redirect to library with success parameter
    setTimeout(() => {
        window.location.href = `index.html?bulk_imported=${successCount}`;
    }, 2000);
        
    } catch (error) {
        console.error('Failed to add items to library:', error);
        LibraryUtils.ui.showStatusMessage('Failed to save items. Please try again.', 'error');
    } finally {
        addAllBtn.classList.remove('saving');
        addAllBtn.disabled = false;
    }
}
function setResultFilter(filter) {
    currentFilter = filter;
    
    // Update active tab
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
    });
    
    renderResults();
}
function removeResult(resultId) {
    scanResults = scanResults.filter(r => r.id !== resultId);
    const barcode = scanResults.find(r => r.id === resultId)?.barcode;
    if (barcode) {
        processedBarcodes.delete(barcode);
    }
    updateStats();
    renderResults();
}
// Updated renderResults function to handle skipped items
function renderResults() {
            const grid = document.getElementById('resultsGrid');
            
            if (scanResults.length === 0) {
                grid.innerHTML = `
                <div class="empty-state">
                    <span class="icon icon-add icon-4xl"></span>
                    <h3>Ready to scan</h3>
                    <p>Start scanning barcodes to see them here</p>
                </div>
                `;
                return;
            }
            
            // Filter results
            let filteredResults = scanResults;
            if (currentFilter !== 'all') {
                filteredResults = scanResults.filter(r => r.status === currentFilter);
            }
                
            if (filteredResults.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <span class="icon icon-details icon-3xl"></span>
                        <h3>No results for "${currentFilter}"</h3>
                        <p>Try scanning more items or switch to another tab.</p>
                    </div>
                `;
                return;
            }
            
            // Sort by timestamp (most recent first)
            filteredResults.sort((a, b) => b.timestamp - a.timestamp);
            
            grid.innerHTML = filteredResults.map(result => {
                const posterSrc = result.poster || 'https://placehold.co/60x90/2D194D/DEF0F7?text=N/A';
                
                // Confidence indicator for needs_review items
                const confidenceIndicator = result.status === 'needs_review' 
                    ? `<p class="bulk-result-confidence">Confidence: ${Math.round(result.confidence || 0)}%</p>` 
                    : '';
                
                // Skip reason for skipped items
                const skipIndicator = result.status === 'skipped'
                    ? `<p class="bulk-result-skipped">${result.skipReason || 'Skipped by user'}</p>`
                    : '';
                
                return `
                    <div class="bulk-result-item status-${result.status}">
                        <img src="${posterSrc}" alt="${result.title}" class="bulk-result-poster" loading="lazy">
                        <div class="bulk-result-info">
                            <h4 class="bulk-result-title">${result.title}</h4>
                            <p class="bulk-result-year">${result.year || 'Unknown'}</p>
                            <p class="bulk-result-barcode">UPC: ${result.barcode}</p>
                            ${result.status === 'failed' ? `<p class="bulk-result-error">${result.error}</p>` : ''}
                            ${result.status === 'needs_review' ? `<p class="bulk-result-warning">Needs manual review</p>` : ''}
                            ${result.status === 'skipped' ? skipIndicator : ''}
                            ${confidenceIndicator}
                            ${result.physicalEdition ? `<p class="bulk-result-format">${result.physicalEdition.format} • ${result.physicalEdition.edition}</p>` : ''}
                        </div>
                        <div class="bulk-result-actions">
                            <button class="btn btn-sm btn-danger" onclick="removeResult(${result.id})" title="Remove">
                                <span class="icon icon-delete icon-sm"></span>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }
function skipCurrent() {
    updateScannerStatus('Skipped. Ready for next barcode...', 'info');
}
// NEW: Review transition function
async function initiateReview() {
        const foundItems = scanResults.filter(r => r.status === 'found');
        const reviewItems = scanResults.filter(r => r.status === 'needs_review');
        
        if (reviewItems.length === 0) {
            LibraryUtils.ui.showStatusMessage('No items need review', 'info');
            return;
        }
        
        try {
            // Step 1: Save all found items immediately
            if (foundItems.length > 0) {
                LibraryUtils.ui.showStatusMessage(`Saving ${foundItems.length} found items...`, 'info');
                
                for (const item of foundItems) {
                    await addMovieToDatabase(item);
                }
                
                LibraryUtils.ui.showStatusMessage(`Saved ${foundItems.length} items to library`, 'success');
            }
            
            // Step 2: Store review items in sessionStorage
            sessionStorage.setItem('reviewQueue', JSON.stringify({
                items: reviewItems,
                timestamp: Date.now(),
                totalFound: foundItems.length
            }));
            
            // Step 3: Navigate to review page
            window.location.href = 'review-failed.html';
            
        } catch (error) {
            console.error('Failed to initiate review:', error);
            LibraryUtils.ui.showStatusMessage('Failed to save items. Please try again.', 'error');
        }
    }
        function finishScanning() {
            if (bulkScanner) {
                    bulkScanner.stopCamera();
                }

            // Update UI
            document.getElementById('scannerSection').style.display = 'none';
            document.getElementById('startScanBtn').style.display = 'inline-flex';
            document.getElementById('finishScanBtn').style.display = 'none';
            updateKeyboardHints();

            const finalActions = document.getElementById('finalActions');
            const foundCount = scanResults.filter(r => r.status === 'found').length;
            const needsReviewCount = scanResults.filter(r => r.status === 'needs_review').length;
            const failedCount = scanResults.filter(r => r.status === 'failed').length;

            // Show final actions if there are ANY items to process
            if (foundCount > 0 || needsReviewCount > 0 || failedCount > 0) {
                finalActions.style.display = 'block';
                finalActions.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Update progress bar during bulk operations
        function updateProgressBar(current, total) {
            const progressContainer = document.getElementById('scanProgress');
            const progressBar = document.getElementById('scanProgressBar');
            
            if (progressContainer && progressBar) {
                if (current > 0 && total > 0) {
                    const percentage = (current / total) * 100;
                    progressBar.style.width = `${percentage}%`;
                    progressContainer.style.display = 'block';
                } else {
                    progressContainer.style.display = 'none';
                }
            }
        }

        // Initialize when auth is ready
        document.addEventListener('DOMContentLoaded', () => {
            auth.onAuthStateChanged(user => {
                if (user) {
                    currentUser = user;
                    initializeBulkScanner();
                } else {
                    window.location.href = 'auth.html'; 
                }
            });
        });
    </script>
</body>
</html>